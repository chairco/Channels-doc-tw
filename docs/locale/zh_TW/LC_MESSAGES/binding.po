# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, test
# This file is distributed under the same license as the test package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: test 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-06-21 02:56+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Jason <chairco@gmail.com>, 2017\n"
"Language: zh_Hant_TW\n"
"Language-Team: Chinese (Taiwan) (https://www.transifex.com/django-"
"channels-tw-docs/teams/72101/zh_TW/)\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../binding.rst:2
msgid "Data Binding"
msgstr "資料綁定"

#: ../../binding.rst:4
msgid ""
"The Channels data binding framework automates the process of tying Django"
" models into frontend views, such as javascript-powered website UIs. It "
"provides a quick and flexible way to generate messages on Groups for "
"model changes and to accept messages that change models themselves."
msgstr ""
"Channel 的資料綁定架構會自動處理 Django 的 model 寫入前端 view 中，例如使用 javascript "
"強化的網站。它提供了一個快速且彈性的方式來產生 Group 的 model 改變 message，以及接收 model 發生變化時的 "
"message。"

#: ../../binding.rst:9
msgid ""
"The main target for the moment is WebSockets, but the framework is "
"flexible enough to be used over any protocol."
msgstr "當前主要的目標是 WebSocket，但此架構有相當的彈性可以支援任何通訊協定。"

#: ../../binding.rst:13
msgid "What does data binding allow?"
msgstr "資料綁定可以接受什麼？"

#: ../../binding.rst:15
msgid "Data binding in Channels works two ways:"
msgstr "Channel 的資料綁定以兩種方式運作:"

#: ../../binding.rst:17
msgid ""
"Outbound, where model changes made through Django are sent out to "
"listening clients. This includes creation, updates and deletion of "
"instances."
msgstr "發送，當 model 透過 Django 發生變化時，訊息會發送到監聽的客戶端。這包含了事例的建立、更新與刪除。"

#: ../../binding.rst:20
msgid ""
"Inbound, where a standardised message format allows creation, update and "
"deletion of instances to be made by clients sending messages."
msgstr "接收，標準化的訊息格式，允許客戶端發送訊息來建立、更新與刪除事例。"

#: ../../binding.rst:23
msgid ""
"Combined, these allow a UI to be designed that automatically updates to "
"reflect new values and reflects across clients. A live blog is easily "
"done using data binding against the post object, for example, or an edit "
"interface can show data live as it's edited by other users."
msgstr ""
"收發，允許 UI 可以設計成自動更新反映客戶端更新的數值。例如，網誌的即時更新可以藉由 PO "
"文物件的資料綁定來達成，而編輯介面也可以藉此同步顯示其他使用者的修改。"

#: ../../binding.rst:28
msgid "It has some limitations:"
msgstr " 資料綁定有以下的限制:"

#: ../../binding.rst:30
msgid ""
"Signals are used to power outbound binding, so if you change the values "
"of a model outside of Django (or use the ``.update()`` method on a "
"QuerySet), the signals are not triggered and the change will not be sent "
"out. You can trigger changes yourself, but you'll need to source the "
"events from the right place for your system."
msgstr ""
"發送的資料綁定是藉由 signal 來達成的，所以假使 model 的資料更新不是透過 Django (或是使用 QuerySet 的 "
"``.update()`` 函式)，就沒有觸發的 "
"signal，改變的訊息就不會被送出。你可以自己觸發改變，但是你會需要從系統中正確的來源來送出這個 signal。"

#: ../../binding.rst:36
msgid ""
"The built-in serializers are based on the built-in Django ones and can "
"only handle certain field types; for more flexibility, you can plug in "
"something like the Django REST Framework serializers."
msgstr ""
"內建的序列化是來自 Django 的內建功能，它只能處理特定的資料型態。如果需要有更大的彈性，你可以透過像是 Django REST "
"架構的序列化函式庫來達成。"

#: ../../binding.rst:41
msgid "Getting Started"
msgstr "入門"

#: ../../binding.rst:43
msgid ""
"A single Binding subclass will handle outbound and inbound binding for a "
"model, and you can have multiple bindings per model (if you want "
"different formats or permission checks, for example)."
msgstr "單一的綁定子類別用來處理 model 發送與接收的綁定，你也可以在每個 model 使用多個綁定 (例如如果你想使用不同的格式或權限檢查)。"

#: ../../binding.rst:47
msgid ""
"You can inherit from the base Binding and provide all the methods needed,"
" but we'll focus on the WebSocket JSON variant here, as it's the easiest "
"thing to get started and likely close to what you want."
msgstr ""
"你可以自底層的 Binding 實作所有需要的函式，但我們這裡把重點放在 WebSocket JSON "
"變形上，因著這是最簡單的入手點而且最接近你可能需要的部分。"

#: ../../binding.rst:51
msgid "Start off like this::"
msgstr "從這裡開始:: "

#: ../../binding.rst:74
msgid ""
"This defines a WebSocket binding - so it knows to send outgoing messages "
"formatted as JSON WebSocket frames - and provides the three things you "
"must always provide:"
msgstr "這裡定義一個 WebSocket 的綁定 - 如此就知道如何送出 JSON WebSocket 格式的頁框 - 並且提供三件你必須提供的部分:"

#: ../../binding.rst:78
msgid ""
"``fields`` is a whitelist of fields to return in the serialized request. "
"Channels does not default to all fields for security concerns; if you "
"want this, set it to the value ``[\"__all__\"]``. As an alternative, "
"``exclude`` acts as a blacklist of fields."
msgstr ""
"``fields`` 是一個序列化請求可傳回欄位的白名單。Channel "
"預設不開啟所有的欄位，主要是基於安全性的考量。如果你想全部開啟的話，把該列表設為 ``[\"__all__\"]`` 即可。另一方便，也可以使用 "
"``exclude`` 來建立黑名單。"

#: ../../binding.rst:83
msgid ""
"``group_names`` returns a list of groups to send outbound updates to "
"based on the instance. For example, you could dispatch posts on different"
" liveblogs to groups that included the parent blog ID in the name; here, "
"we just use a fixed group name. Based on how ``group_names`` changes as "
"the instance changes, Channels will work out if clients need ``create``, "
"``update`` or ``delete`` messages (or if the change is hidden from them)."
msgstr ""
"``group_names`` 傳回一個基於該事例的外送更新群組列表。例如，你可以發送PO文到名稱包含父網誌 ID "
"的不同即時網誌中。這裡我們只用一個固定的群組名稱。基於 ``group_names`` 如何隨著事例的改變，Channels 將會處理客戶端需要的"
" ``create``, ``update`` 或 ``delete`` 等訊息 (或是改變是對客戶端隱藏的)。"

#: ../../binding.rst:90
msgid ""
"``has_permission`` returns if an inbound binding update is allowed to "
"actually be carried out on the model. We've been very unsafe and made it "
"always return ``True``, but here is where you would check against either "
"Django's or your own permission system to see if the user is allowed that"
" action."
msgstr ""
"``has_permission`` 則傳回一個接收綁定更新，是否會被 model 執行的許可與否。我們採取了一個非常不安全的作法，總是回傳 "
"``True``。但是這裡就是你可以讓 Django 做檢查或是自行撰寫權限系統的地方。"

#: ../../binding.rst:95
msgid ""
"For reference, ``action`` is always one of the unicode strings "
"``\"create\"``, ``\"update\"`` or ``\"delete\"``. You also supply the "
":ref:`multiplexing` stream name to provide to the client - you must use "
"multiplexing if you use WebSocket data binding."
msgstr ""
"做為參考， ``action`` 總是以下 ``\"create\"``, ``\"update\"`` 或 ``\"delete\"`` "
"之一的萬國碼字串。你也可以提供 :ref:`multiplexing` 串流名稱給客戶端，如果使用 WebSocket "
"資料綁定，你必須使用多工化。"

#: ../../binding.rst:100
msgid ""
"Just adding the binding like this in a place where it will be imported "
"will get outbound messages sending, but you still need a Consumer that "
"will both accept incoming binding updates and add people to the right "
"Groups when they connect. The WebSocket binding classes use the standard "
":ref:`multiplexing`, so you just need to use that::"
msgstr ""
"只要如此新增一個綁定在匯入的地方，發送綁定訊息就會被送出，但你仍需要提供一個 Consumer "
"來接受進來的綁定更新，並且在連線時將人加到正確的群組。WebSocket 綁定類別使用標準的 :ref:`multiplexing` "
"，因此你只需要使用它。"

#: ../../binding.rst:118
msgid ""
"As well as the standard stream-to-consumer mapping, you also need to set "
"``connection_groups``, a list of groups to put people in when they "
"connect. This should match the logic of ``group_names`` on your binding -"
" we've used our fixed group name again. Notice that the binding has a "
"``.consumer`` attribute; this is a standard WebSocket-JSON consumer, that"
" the demultiplexer can pass demultiplexed ``websocket.receive`` messages "
"to."
msgstr ""
"如同標準的串流對消費者映射，你也需要指定 ``connection_groups``，一個將上線使用者加入群組的列表。這也符合 "
"``group_names`` 在你的綁定上的邏輯，這裡我們使用一個固定的群組名稱。請注意，綁定有一個 ``.consumer`` "
"屬性，這是一個標準 WebSocket-JSON consumer，解多工器可以發送解開的 ``websocket.receive`` 訊息給這個"
" consumer。"

#: ../../binding.rst:125
msgid "Tie that into your routing, and you're ready to go::"
msgstr "綁到你的路由，這樣子就完成了:: "

#: ../../binding.rst:137
msgid "Frontend Considerations"
msgstr "前端的考量點"

#: ../../binding.rst:139
#, fuzzy
msgid ""
"You can use the standard :doc:`Channels WebSocket wrapper <javascript>` "
"to automatically run demultiplexing, and then tie the events you receive "
"into your frontend framework of choice based on ``action``, ``pk`` and "
"``data``."
msgstr ""
"你可以使用 Channel 標準的 WebSocket 包裹 **(尚未提供)** 來自動反解多工，然後將接收的事例綁到你選定之前端架構的 "
"``action``, ``pk`` 與 ``data`` 上。"

#: ../../binding.rst:145
msgid ""
"Common plugins for data binding against popular JavaScript frameworks are"
" wanted; if you're interested, please get in touch."
msgstr "我們需要熱門 JavaScript 架構的資料綁定插件，如果你有興趣提供，請和我們聯絡。"

#: ../../binding.rst:150
msgid "Custom Serialization/Protocols"
msgstr "客製序列化/通訊協定"

#: ../../binding.rst:152
msgid ""
"Rather than inheriting from the ``WebsocketBinding``, you can inherit "
"directly from the base ``Binding`` class and implement serialization and "
"deserialization yourself. Until proper reference documentation for this "
"is written, we recommend looking at the source code in "
"``channels/bindings/base.py``; it's reasonably well-commented."
msgstr ""
"不同於繼承自 ``WebsocketBinding``，你可以直接繼承自底層的 ``Binding`` "
"類別，然後自己實作序列化與反序列化。在這部分的參考文件完成之前，我們建議參考 ``channels/bindings/base.py`` "
"原始碼，程式中有相當完整的註解。"

#: ../../binding.rst:160
msgid "Dealing with Disconnection"
msgstr "斷線的處理"

#: ../../binding.rst:162
msgid ""
"Because the data binding Channels ships with has no history of events, it"
" means that when a disconnection happens you may miss events that happen "
"during your offline time. For this reason, it's recommended you reload "
"data directly using an API call once connection has been re-established, "
"don't rely on the live updates for critical functionality, or have UI "
"designs that cope well with missing data (e.g. ones where it's all "
"updates and no creates, so the next update will correct everything)."
msgstr ""
"由於 Channel 的資料綁定沒有包含事件的歷史，也就是說當網路連線斷開，你會遺失這段時間發生的事例訊息。因此，建議當連線恢復之後，直接透過 "
"API 來重新載入資料，而不要依賴即時更新在關鍵的功能，或是設計 UI "
"來處理資料遺失的問題。(例如只有更新沒有新建時，下個更新會修正全部的遺失資料)"

