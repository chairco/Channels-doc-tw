# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, test
# This file is distributed under the same license as the test package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: test 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-06-21 02:56+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Jason <chairco@gmail.com>, 2017\n"
"Language: zh_Hant_TW\n"
"Language-Team: Chinese (Taiwan) (https://www.transifex.com/django-"
"channels-tw-docs/teams/72101/zh_TW/)\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../asgi.rst:3
msgid "ASGI (Asynchronous Server Gateway Interface) Draft Spec"
msgstr "ASGI (異步伺服器閘道介面) 規劃草案"

#: ../../asgi.rst:6
msgid "This is still in-progress, but is now mostly complete."
msgstr ""

#: ../../asgi.rst:9
msgid "Abstract"
msgstr "摘要"

#: ../../asgi.rst:11
#, fuzzy
msgid ""
"This document proposes a standard interface between network protocol "
"servers (particularly web servers) and Python applications, intended to "
"allow handling of multiple common protocol styles (including HTTP, HTTP2,"
" and WebSocket)."
msgstr ""
"此文件提供一個標準介面連結網路伺服器 (特別是 web 伺服器) 和 Python 應用程式，允許處理多種常見的協議樣式(包括 "
"HTTP，HTTP2 和 WebSocket )。"

#: ../../asgi.rst:16
msgid ""
"This base specification is intended to fix in place the set of APIs by "
"which these servers interact and the guarantees and style of message "
"delivery; each supported protocol (such as HTTP) has a sub-specification "
"that outlines how to encode and decode that protocol into messages."
msgstr ""

#: ../../asgi.rst:21
msgid ""
"The set of sub-specifications is available :ref:`in the Message Formats "
"section <asgi_sub_specifications>`."
msgstr ""

#: ../../asgi.rst:25
msgid "Rationale"
msgstr "說明"

#: ../../asgi.rst:27
msgid ""
"The WSGI specification has worked well since it was introduced, and "
"allowed for great flexibility in Python framework and web server choice. "
"However, its design is irrevocably tied to the HTTP-style "
"request/response cycle, and more and more protocols are becoming a "
"standard part of web programming that do not follow this pattern (most "
"notably, WebSocket)."
msgstr ""

#: ../../asgi.rst:34
msgid ""
"ASGI attempts to preserve a simple application interface, but provide an "
"abstraction that allows for data to be sent and received at any time, and"
" from different application threads or processes."
msgstr ""

#: ../../asgi.rst:38
msgid ""
"It also take the principle of turning protocols into Python-compatible, "
"asynchronous-friendly sets of messages and generalises it into two parts;"
" a standardised interface for communication and to build servers around "
"(this document), and a set of standard :ref:`message formats for each "
"protocol <asgi_sub_specifications>`."
msgstr ""

#: ../../asgi.rst:43
#, fuzzy
msgid ""
"Its primary goal is to provide a way to write HTTP/2 and WebSocket code, "
"alongside normal HTTP handling code, however, and part of this design is "
"ensuring there is an easy path to use both existing WSGI servers and "
"applications, as a large majority of Python web usage relies on WSGI and "
"providing an easy path forwards is critical to adoption. Details on that "
"interoperability are covered in :doc:`/asgi/www`."
msgstr ""
"此設計的一部分是確保有一個簡單的路徑來使用現有的 WSGI 服務器和應用程式，因為大多數的 Python Web 使用依賴於 WSGI "
"並提供一個簡單的路徑轉發是採用的關鍵。"

#: ../../asgi.rst:50
msgid ""
"The end result of this process has been a specification for generalised "
"inter-process communication between Python processes, with a certain set "
"of guarantees and delivery styles that make it suited to low-latency "
"protocol processing and response. It is not intended to replace things "
"like traditional task queues, but it is intended that it could be used "
"for things like distributed systems communication, or as the backbone of "
"a service-oriented architecure for inter-service communication."
msgstr ""

#: ../../asgi.rst:60
msgid "Overview"
msgstr "總覽"

#: ../../asgi.rst:62
msgid ""
"ASGI consists of three different components - *protocol servers*, a "
"*channel layer*, and *application code*. Channel layers are the core part"
" of the implementation, and provide an interface to both protocol servers"
" and applications."
msgstr ""

#: ../../asgi.rst:67
msgid ""
"A channel layer provides a protocol server or an application server with "
"a ``send`` callable, which takes a channel name and message ``dict``, and"
" a ``receive`` callable, which takes a list of channel names and returns "
"the next message available on any named channel."
msgstr ""

#: ../../asgi.rst:72
msgid ""
"Thus, rather than under WSGI, where you point the protocol server to the "
"application, under ASGI you point both the protocol server and the "
"application to a channel layer instance. It is intended that applications"
" and protocol servers always run in separate processes or threads, and "
"always communicate via the channel layer."
msgstr ""

#: ../../asgi.rst:78
msgid ""
"ASGI tries to be as compatible as possible by default, and so the only "
"implementation of ``receive`` that must be provided is a fully-"
"synchronous, nonblocking one. Implementations can then choose to "
"implement a blocking mode in this method, and if they wish to go further,"
" versions compatible with the asyncio or Twisted frameworks (or other "
"frameworks that may become popular, thanks to the extension declaration "
"mechanism)."
msgstr ""

#: ../../asgi.rst:85
msgid ""
"The distinction between protocol servers and applications in this "
"document is mostly to distinguish their roles and to make illustrating "
"concepts easier. There is no code-level distinction between the two, and "
"it's entirely possible to have a process that does both, or middleware-"
"like code that transforms messages between two different channel layers "
"or channel names. It is expected, however, that most deployments will "
"fall into this pattern."
msgstr ""

#: ../../asgi.rst:92
msgid ""
"There is even room for a WSGI-like application abstraction on the "
"application server side, with a callable which takes ``(channel, message,"
" send_func)``, but this would be slightly too restrictive for many use "
"cases and does not cover how to specify channel names to listen on. It is"
" expected that frameworks will cover this use case."
msgstr ""

#: ../../asgi.rst:100
msgid "Channels and Messages"
msgstr "路徑與訊息"

#: ../../asgi.rst:102
msgid ""
"All communication in an ASGI stack uses *messages* sent over *channels*. "
"All messages must be a ``dict`` at the top level of the object, and "
"contain only the following types to ensure serializability:"
msgstr ""

#: ../../asgi.rst:106
msgid "Byte strings"
msgstr "Byte 字串"

#: ../../asgi.rst:107
msgid "Unicode strings"
msgstr "Unicode 字串"

#: ../../asgi.rst:108
msgid "Integers (within the signed 64 bit range)"
msgstr ""

#: ../../asgi.rst:109
msgid "Floating point numbers (within the IEEE 754 double precision range)"
msgstr ""

#: ../../asgi.rst:110
msgid "Lists (tuples should be treated as lists)"
msgstr "列表(元組會被視為列表)"

#: ../../asgi.rst:111
msgid "Dicts (keys must be unicode strings)"
msgstr ""

#: ../../asgi.rst:112
msgid "Booleans"
msgstr ""

#: ../../asgi.rst:113
msgid "None"
msgstr "None"

#: ../../asgi.rst:115
msgid ""
"Channels are identified by a unicode string name consisting only of ASCII"
" letters, ASCII numerical digits, periods (``.``), dashes (``-``) and "
"underscores (``_``), plus an optional type character (see below)."
msgstr ""

#: ../../asgi.rst:119
msgid ""
"Channels are a first-in, first out queue with at-most-once delivery "
"semantics. They can have multiple writers and multiple readers; only a "
"single reader should get each written message. Implementations must never"
" deliver a message more than once or to more than one reader, and must "
"drop messages if this is necessary to achieve this restriction."
msgstr ""

#: ../../asgi.rst:125
#, fuzzy
msgid ""
"In order to aid with scaling and network architecture, a distinction is "
"made between channels that have multiple readers (such as the "
"``http.request`` channel that web applications would listen on from every"
" application worker process), *single-reader channels* that are read from"
" a single unknown location (such as ``http.request.body?ABCDEF``), and "
"*process-specific channels* (such as a ``http.response.A1B2C3!D4E5F6`` "
"channel tied to a client socket)."
msgstr ""
"為了輔助縮放和網頁架構，在具有多個讀取器的通道之間進行區分(例如，web 應用將從每個應用工作進程監聽的 ``http.reques`` "
"通道)，*單讀取器通道* 從一個未知位置讀取(例如 ``http.request.body？ABCDEF`` )， 和 *進程特定的通道* "
"(例如綁定到客戶端的``http.response！ABCDEF`` 通道插座)。"

#: ../../asgi.rst:133
msgid ""
"*Normal channel* names contain no type characters, and can be routed "
"however the backend wishes; in particular, they do not have to appear "
"globally consistent, and backends may shard their contents out to "
"different servers so that a querying client only sees some portion of the"
" messages. Calling ``receive`` on these channels does not guarantee that "
"you will get the messages in order or that you will get anything if the "
"channel is non-empty."
msgstr ""

#: ../../asgi.rst:140
msgid ""
"*Single-reader channel* names contain a question mark (``?``) character "
"in order to indicate to the channel layer that it must make these "
"channels appear globally consistent. The ``?`` is always preceded by the "
"main channel name (e.g. ``http.response.body``) and followed by a random "
"portion. Channel layers may use the random portion to help pin the "
"channel to a server, but reads from this channel by a single process must"
" always be in-order and return messages if the channel is non-empty. "
"These names must be generated by the ``new_channel`` call."
msgstr ""

#: ../../asgi.rst:149
msgid ""
"*Process-specific channel* names contain an exclamation mark (``!``) that"
" separates a remote and local part. These channels are received "
"differently; only the name up to and including the ``!`` character is "
"passed to the ``receive()`` call, and it will receive any message on any "
"channel with that prefix. This allows a process, such as a HTTP "
"terminator, to listen on a single process-specific channel, and then "
"distribute incoming requests to the appropriate client sockets using the "
"local part (the part after the ``!``). The local parts must be generated "
"and managed by the process that consumes them. These channels, like "
"single-reader channels, are guaranteed to give any extant messages in "
"order if received from a single process."
msgstr ""

#: ../../asgi.rst:160
msgid ""
"Messages should expire after a set time sitting unread in a channel; the "
"recommendation is one minute, though the best value depends on the "
"channel layer and the way it is deployed."
msgstr ""

#: ../../asgi.rst:164
msgid ""
"The maximum message size is 1MB if the message were encoded as JSON; if "
"more data than this needs to be transmitted it must be chunked or placed "
"onto its own single-reader or process-specific channel (see how HTTP "
"request bodies are done, for example). All channel layers must support "
"messages up to this size, but protocol specifications are encouraged to "
"keep well below it."
msgstr ""

#: ../../asgi.rst:172
msgid "Handling Protocols"
msgstr "處理協議"

#: ../../asgi.rst:174
msgid ""
"ASGI messages represent two main things - internal application events "
"(for example, a channel might be used to queue thumbnails of previously "
"uploaded videos), and protocol events to/from connected clients."
msgstr ""

#: ../../asgi.rst:178
msgid ""
"As such, there are :ref:`sub-specifications <asgi_sub_specifications>` "
"that outline encodings to and from ASGI messages for common protocols "
"like HTTP and WebSocket; in particular, the HTTP one covers the WSGI/ASGI"
" interoperability. It is recommended that if a protocol becomes "
"commonplace, it should gain standardized formats in a sub-specification "
"of its own."
msgstr ""

#: ../../asgi.rst:184
msgid ""
"The message formats are a key part of the specification; without them, "
"the protocol server and web application might be able to talk to each "
"other, but may not understand some of what the other is saying. It's "
"equivalent to the standard keys in the ``environ`` dict for WSGI."
msgstr ""

#: ../../asgi.rst:189
msgid ""
"The design pattern is that most protocols will share a few channels for "
"incoming data (for example, ``http.request``, ``websocket.connect`` and "
"``websocket.receive``), but will have individual channels for sending to "
"each client (such as ``http.response!kj2daj23``). This allows incoming "
"data to be dispatched into a cluster of application servers that can all "
"handle it, while responses are routed to the individual protocol server "
"that has the other end of the client's socket."
msgstr ""

#: ../../asgi.rst:197
msgid ""
"Some protocols, however, do not have the concept of a unique socket "
"connection; for example, an SMS gateway protocol server might just have "
"``sms.receive`` and ``sms.send``, and the protocol server cluster would "
"take messages from ``sms.send`` and route them into the normal phone "
"network based on attributes in the message (in this case, a telephone "
"number)."
msgstr ""

#: ../../asgi.rst:208
msgid "Extensions"
msgstr ""

#: ../../asgi.rst:210
msgid ""
"Extensions are functionality that is not required for basic application "
"code and nearly all protocol server code, and so has been made optional "
"in order to enable lightweight channel layers for applications that don't"
" need the full feature set defined here."
msgstr ""

#: ../../asgi.rst:216
msgid "The extensions defined here are:"
msgstr "此處擴充定義為:"

#: ../../asgi.rst:218
msgid ""
"``groups``: Allows grouping of channels to allow broadcast; see below for"
" more."
msgstr ""

#: ../../asgi.rst:219
msgid "``flush``: Allows easier testing and development with channel layers."
msgstr ""

#: ../../asgi.rst:220
msgid ""
"``statistics``: Allows channel layers to provide global and per-channel "
"statistics."
msgstr ""

#: ../../asgi.rst:221
msgid "``twisted``: Async compatibility with the Twisted framework."
msgstr ""

#: ../../asgi.rst:222
msgid "``asyncio``: Async compatibility with Python 3's asyncio."
msgstr ""

#: ../../asgi.rst:224
msgid ""
"There is potential to add further extensions; these may be defined by a "
"separate specification, or a new version of this specification."
msgstr ""

#: ../../asgi.rst:227
msgid ""
"If application code requires an extension, it should check for it as soon"
" as possible, and hard error if it is not provided. Frameworks should "
"encourage optional use of extensions, while attempting to move any "
"extension-not-found errors to process startup rather than message "
"handling."
msgstr ""

#: ../../asgi.rst:234
msgid "Groups"
msgstr ""

#: ../../asgi.rst:236
msgid ""
"While the basic channel model is sufficient to handle basic application "
"needs, many more advanced uses of asynchronous messaging require "
"notifying many users at once when an event occurs - imagine a live blog, "
"for example, where every viewer should get a long poll response or "
"WebSocket packet when a new entry is posted."
msgstr ""

#: ../../asgi.rst:242
msgid ""
"This concept could be kept external to the ASGI spec, and would be, if it"
" were not for the significant performance gains a channel layer "
"implementation could make on the send-group operation by having it "
"included - the alternative being a ``send_many`` callable that might have"
" to take tens of thousands of destination channel names in a single call."
" However, the group feature is still optional; its presence is indicated "
"by the ``supports_groups`` attribute on the channel layer object."
msgstr ""

#: ../../asgi.rst:250
msgid ""
"Thus, there is a simple Group concept in ASGI, which acts as the "
"broadcast/multicast mechanism across channels. Channels are added to a "
"group, and then messages sent to that group are sent to all members of "
"the group. Channels can be removed from a group manually (e.g. based on a"
" disconnect event), and the channel layer will garbage collect \"old\" "
"channels in groups on a periodic basis."
msgstr ""

#: ../../asgi.rst:257
msgid ""
"How this garbage collection happens is not specified here, as it depends "
"on the internal implementation of the channel layer. The recommended "
"approach, however, is when a message on a process-specific channel "
"expires, the channel layer should remove that channel from all groups "
"it's currently a member of; this is deemed an acceptable indication that "
"the channel's listener is gone."
msgstr ""

#: ../../asgi.rst:263
msgid ""
"*Implementation of the group functionality is optional*. If it is not "
"provided and an application or protocol server requires it, they should "
"hard error and exit with an appropriate error message. It is expected "
"that protocol servers will not need to use groups."
msgstr ""

#: ../../asgi.rst:270
msgid "Linearization"
msgstr "線性化"

#: ../../asgi.rst:272
msgid ""
"The design of ASGI is meant to enable a shared-nothing architecture, "
"where messages can be handled by any one of a set of threads, processes "
"or machines running application code."
msgstr "ASGI 的設計目的為在實現無共享架構下，其中訊息可以藉由一組 threads，processes 或機器其中的任何一個來處理運行的應用程序代碼。"

#: ../../asgi.rst:276
msgid ""
"This, of course, means that several different copies of the application "
"could be handling messages simultaneously, and those messages could even "
"be from the same client; in the worst case, two packets from a client "
"could even be processed out-of-order if one server is slower than "
"another."
msgstr ""

#: ../../asgi.rst:281
msgid ""
"This is an existing issue with things like WSGI as well - a user could "
"open two different tabs to the same site at once and launch simultaneous "
"requests to different servers - but the nature of the new protocols "
"specified here mean that collisions are more likely to occur."
msgstr ""

#: ../../asgi.rst:286
msgid ""
"Solving this issue is left to frameworks and application code; there are "
"already solutions such as database transactions that help solve this, and"
" the vast majority of application code will not need to deal with this "
"problem. If ordering of incoming packets matters for a protocol, they "
"should be annotated with a packet number (as WebSocket is in its "
"specification)."
msgstr ""

#: ../../asgi.rst:292
msgid ""
"Single-reader and process-specific channels, such as those used for "
"response channels back to clients, are not subject to this problem; a "
"single reader on these must always receive messages in channel order."
msgstr ""

#: ../../asgi.rst:298
msgid "Capacity"
msgstr "容量"

#: ../../asgi.rst:300
msgid ""
"To provide backpressure, each channel in a channel layer may have a "
"capacity, defined however the layer wishes (it is recommended that it is "
"configurable by the user using keyword arguments to the channel layer "
"constructor, and furthermore configurable per channel name or name "
"prefix)."
msgstr ""

#: ../../asgi.rst:305
msgid ""
"When a channel is at or over capacity, trying to send() to that channel "
"may raise ChannelFull, which indicates to the sender the channel is over "
"capacity. How the sender wishes to deal with this will depend on context;"
" for example, a web application trying to send a response body will "
"likely wait until it empties out again, while a HTTP interface server "
"trying to send in a request would drop the request and return a 503 "
"error."
msgstr ""

#: ../../asgi.rst:312
msgid ""
"Process-local channels must apply their capacity on the non-local part "
"(that is, up to and including the ``!`` character), and so capacity is "
"shared among all of the \"virtual\" channels inside it."
msgstr ""

#: ../../asgi.rst:316
msgid ""
"Sending to a group never raises ChannelFull; instead, it must silently "
"drop the message if it is over capacity, as per ASGI's at-most-once "
"delivery policy."
msgstr ""

#: ../../asgi.rst:322
msgid "Specification Details"
msgstr "規格明細"

#: ../../asgi.rst:324
msgid ""
"A *channel layer* must provide an object with these attributes (all "
"function arguments are positional):"
msgstr "一個 *路徑圖層* 必須有個物件具有這些屬性(所有函數參數都有方位性)："

#: ../../asgi.rst:327
msgid ""
"``send(channel, message)``, a callable that takes two arguments: the "
"channel to send on, as a unicode string, and the message to send, as a "
"serializable ``dict``."
msgstr ""

#: ../../asgi.rst:331
msgid ""
"``receive(channels, block=False)``, a callable that takes a list of "
"channel names as unicode strings, and returns with either ``(None, "
"None)`` or ``(channel, message)`` if a message is available. If ``block``"
" is True, then it will not return a message arrives (or optionally, a "
"built-in timeout, but it is valid to block forever if there are no "
"messages); if ``block`` is false, it will always return immediately. It "
"is perfectly valid to ignore ``block`` and always return immediately, or "
"after a delay; ``block`` means that the call can take as long as it likes"
" before returning a message or nothing, not that it must block until it "
"gets one."
msgstr ""

#: ../../asgi.rst:341
msgid ""
"``new_channel(pattern)``, a callable that takes a unicode string pattern,"
" and returns a new valid channel name that does not already exist, by "
"adding a unicode string after the ``!`` or ``?`` character in "
"``pattern``, and checking for existence of that name in the channel "
"layer. The ``pattern`` must end with ``!`` or ``?`` or this function must"
" error. If the character is ``!``, making it a process-specific channel, "
"``new_channel`` must be called on the same channel layer that intends to "
"read the channel with ``receive``; any other channel layer instance may "
"not receive messages on this channel due to client-routing portions of "
"the appended string."
msgstr ""

#: ../../asgi.rst:351
msgid ""
"``MessageTooLarge``, the exception raised when a send operation fails "
"because the encoded message is over the layer's size limit."
msgstr ""

#: ../../asgi.rst:354
msgid ""
"``ChannelFull``, the exception raised when a send operation fails because"
" the destination channel is over capacity."
msgstr ""

#: ../../asgi.rst:357
msgid ""
"``extensions``, a list of unicode string names indicating which "
"extensions this layer provides, or an empty list if it supports none. The"
" possible extensions can be seen in :ref:`asgi_extensions`."
msgstr ""

#: ../../asgi.rst:361
msgid "A channel layer implementing the ``groups`` extension must also provide:"
msgstr ""

#: ../../asgi.rst:363
msgid ""
"``group_add(group, channel)``, a callable that takes a ``channel`` and "
"adds it to the group given by ``group``. Both are unicode strings. If the"
" channel is already in the group, the function should return normally."
msgstr ""

#: ../../asgi.rst:367
msgid ""
"``group_discard(group, channel)``, a callable that removes the "
"``channel`` from the ``group`` if it is in it, and does nothing "
"otherwise."
msgstr ""

#: ../../asgi.rst:370
msgid ""
"``group_channels(group)``, a callable that returns an iterable which "
"yields all of the group's member channel names. The return value should "
"be serializable with regards to local adds and discards, but best-effort "
"with regards to adds and discards on other nodes."
msgstr ""

#: ../../asgi.rst:375
msgid ""
"``send_group(group, message)``, a callable that takes two positional "
"arguments; the group to send to, as a unicode string, and the message to "
"send, as a serializable ``dict``. It may raise MessageTooLarge but cannot"
" raise ChannelFull."
msgstr ""

#: ../../asgi.rst:380
msgid ""
"``group_expiry``, an integer number of seconds that specifies how long "
"group membership is valid for after the most recent ``group_add`` call "
"(see *Persistence* below)"
msgstr ""

#: ../../asgi.rst:384
msgid ""
"A channel layer implementing the ``statistics`` extension must also "
"provide:"
msgstr "路徑層架構的 ``統計`` 擴充功能需具備："

#: ../../asgi.rst:386
msgid ""
"``global_statistics()``, a callable that returns statistics across all "
"channels"
msgstr ""

#: ../../asgi.rst:387
msgid ""
"``channel_statistics(channel)``, a callable that returns statistics for "
"specified channel"
msgstr ""

#: ../../asgi.rst:389
msgid ""
"in both cases statistics are a dict with zero or more of (unicode string "
"keys):"
msgstr ""

#: ../../asgi.rst:391
msgid "``messages_count``, the number of messages processed since server start"
msgstr ""

#: ../../asgi.rst:392
msgid ""
"``messages_count_per_second``, the number of messages processed in the "
"last second"
msgstr ""

#: ../../asgi.rst:393
msgid "``messages_pending``, the current number of messages waiting"
msgstr ""

#: ../../asgi.rst:394
msgid ""
"``messages_max_age``, how long the oldest message has been waiting, in "
"seconds"
msgstr ""

#: ../../asgi.rst:395
msgid ""
"``channel_full_count``, the number of times `ChannelFull` exception has "
"been risen since server start"
msgstr ""

#: ../../asgi.rst:396
msgid ""
"``channel_full_count_per_second``, the number of times `ChannelFull` "
"exception has been risen in the last second"
msgstr ""

#: ../../asgi.rst:398
msgid "Implementation may provide total counts, counts per seconds or both."
msgstr "執行可提供次數總和、每秒次數，或是兩者皆提供。"

#: ../../asgi.rst:401
msgid "A channel layer implementing the ``flush`` extension must also provide:"
msgstr ""

#: ../../asgi.rst:403
msgid ""
"``flush()``, a callable that resets the channel layer to a blank state, "
"containing no messages and no groups (if the groups extension is "
"implemented). This call must block until the system is cleared and will "
"consistently look empty to any client, if the channel layer is "
"distributed."
msgstr ""

#: ../../asgi.rst:408
msgid "A channel layer implementing the ``twisted`` extension must also provide:"
msgstr ""

#: ../../asgi.rst:410
msgid ""
"``receive_twisted(channels)``, a function that behaves like ``receive`` "
"but that returns a Twisted Deferred that eventually returns either "
"``(channel, message)`` or ``(None, None)``. It is not possible to run it "
"in nonblocking mode; use the normal ``receive`` for that."
msgstr ""

#: ../../asgi.rst:415
#, fuzzy
msgid "A channel layer implementing the ``async`` extension must also provide:"
msgstr "路徑層架構的 ``統計`` 擴充功能需具備："

#: ../../asgi.rst:417
msgid ""
"``receive_async(channels)``, a function that behaves like ``receive`` but"
" that fulfills the asyncio coroutine contract to block until either a "
"result is available or an internal timeout is reached and ``(None, "
"None)`` is returned. It is not possible to run it in nonblocking mode; "
"use the normal ``receive`` for that."
msgstr ""

#: ../../asgi.rst:424
msgid "Channel Semantics"
msgstr "Channel 語義"

#: ../../asgi.rst:426
msgid "Channels **must**:"
msgstr ""

#: ../../asgi.rst:428
msgid ""
"Preserve ordering of messages perfectly with only a single reader and "
"writer if the channel is a *single-reader* or *process-specific* channel."
msgstr ""

#: ../../asgi.rst:431
msgid "Never deliver a message more than once."
msgstr "請勿重覆傳送相同訊息超過一次。"

#: ../../asgi.rst:433
msgid ""
"Never block on message send (though they may raise ChannelFull or "
"MessageTooLarge)"
msgstr ""

#: ../../asgi.rst:436
msgid ""
"Be able to handle messages of at least 1MB in size when encoded as JSON "
"(the implementation may use better encoding or compression, as long as it"
" meets the equivalent size)"
msgstr ""

#: ../../asgi.rst:440
msgid "Have a maximum name length of at least 100 bytes."
msgstr "最長名稱的長度為 100 bytes。"

#: ../../asgi.rst:442
msgid ""
"They should attempt to preserve ordering in all cases as much as "
"possible, but perfect global ordering is obviously not possible in the "
"distributed case."
msgstr ""

#: ../../asgi.rst:445
#, python-format
msgid ""
"They are not expected to deliver all messages, but a success rate of at "
"least 99.99% is expected under normal circumstances. Implementations may "
"want to have a \"resilience testing\" mode where they deliberately drop "
"more messages than usual so developers can test their code's handling of "
"these scenarios."
msgstr ""

#: ../../asgi.rst:452
msgid "Persistence"
msgstr ""

#: ../../asgi.rst:454
msgid ""
"Channel layers do not need to persist data long-term; group memberships "
"only need to live as long as a connection does, and messages only as long"
" as the message expiry time, which is usually a couple of minutes."
msgstr ""

#: ../../asgi.rst:458
msgid ""
"That said, if a channel server goes down momentarily and loses all data, "
"persistent socket connections will continue to transfer incoming data and"
" send out new generated data, but will have lost all of their group "
"memberships and in-flight messages."
msgstr ""

#: ../../asgi.rst:463
msgid ""
"In order to avoid a nasty set of bugs caused by these half-deleted "
"sockets, protocol servers should quit and hard restart if they detect "
"that the channel layer has gone down or lost data; shedding all existing "
"connections and letting clients reconnect will immediately resolve the "
"problem."
msgstr ""

#: ../../asgi.rst:468
msgid ""
"If a channel layer implements the ``groups`` extension, it must persist "
"group membership until at least the time when the member channel has a "
"message expire due to non-consumption, after which it may drop membership"
" at any time. If a channel subsequently has a successful delivery, the "
"channel layer must then not drop group membership until another message "
"expires on that channel."
msgstr ""

#: ../../asgi.rst:474
msgid ""
"Channel layers must also drop group membership after a configurable long "
"timeout after the most recent ``group_add`` call for that membership, the"
" default being 86,400 seconds (one day). The value of this timeout is "
"exposed as the ``group_expiry`` property on the channel layer."
msgstr ""

#: ../../asgi.rst:479
msgid ""
"Protocol servers must have a configurable timeout value for every "
"connection-based protocol they serve that closes the connection after the"
" timeout, and should default this value to the value of ``group_expiry``,"
" if the channel layer provides it. This allows old group memberships to "
"be cleaned up safely, knowing that after the group expiry the original "
"connection must have closed, or is about to be in the next few seconds."
msgstr ""

#: ../../asgi.rst:486
msgid ""
"It's recommended that end developers put the timeout setting much lower -"
" on the order of hours or minutes - to enable better protocol design and "
"testing. Even with ASGI's separation of protocol server restart from "
"business logic restart, you will likely need to move and reprovision "
"protocol servers, and making sure your code can cope with this is "
"important."
msgstr ""

#: ../../asgi.rst:496
msgid "Message Formats"
msgstr "訊息格式"

#: ../../asgi.rst:498
msgid ""
"These describe the standardized message formats for the protocols this "
"specification supports. All messages are ``dicts`` at the top level, and "
"all keys are required unless explicitly marked as optional. If a key is "
"marked optional, a default value is specified, which is to be assumed if "
"the key is missing. Keys are unicode strings."
msgstr ""

#: ../../asgi.rst:504
msgid ""
"The one common key across all protocols is ``reply_channel``, a way to "
"indicate the client-specific channel to send responses to. Protocols are "
"generally encouraged to have one message type and one reply channel type "
"to ensure ordering."
msgstr ""

#: ../../asgi.rst:508
msgid ""
"A ``reply_channel`` should be unique per connection. If the protocol in "
"question can have any server service a response - e.g. a theoretical SMS "
"protocol - it should not have ``reply_channel`` attributes on messages, "
"but instead a separate top-level outgoing channel."
msgstr ""

#: ../../asgi.rst:513
msgid ""
"Messages are specified here along with the channel names they are "
"expected on; if a channel name can vary, such as with reply channels, the"
" varying portion will be represented by ``!``, such as "
"``http.response!``, which matches the format the ``new_channel`` callable"
" takes."
msgstr ""

#: ../../asgi.rst:518
msgid ""
"There is no label on message types to say what they are; their type is "
"implicit in the channel name they are received on. Two types that are "
"sent on the same channel, such as HTTP responses and response chunks, are"
" distinguished apart by their required fields."
msgstr ""

#: ../../asgi.rst:523
msgid "Message formats can be found in the sub-specifications:"
msgstr ""

#: ../../asgi.rst:534
msgid "Protocol Format Guidelines"
msgstr "協議格式指南"

#: ../../asgi.rst:536
msgid ""
"Message formats for protocols should follow these rules, unless a very "
"good performance or implementation reason is present:"
msgstr ""

#: ../../asgi.rst:539
msgid ""
"``reply_channel`` should be unique per logical connection, and not per "
"logical client."
msgstr ""

#: ../../asgi.rst:542
msgid ""
"If the protocol has server-side state, entirely encapsulate that state in"
" the protocol server; do not require the message consumers to use an "
"external state store."
msgstr ""

#: ../../asgi.rst:546
msgid ""
"If the protocol has low-level negotiation, keepalive or other features, "
"handle these within the protocol server and don't expose them in ASGI "
"messages."
msgstr ""

#: ../../asgi.rst:550
msgid ""
"If the protocol has guaranteed ordering and does not use a specific "
"channel for a given connection (as HTTP does for body data), ASGI "
"messages should include an ``order`` field (0-indexed) that preserves the"
" ordering as received by the protocol server (or as sent by the client, "
"if available). This ordering should span all message types emitted by the"
" client - for example, a connect message might have order ``0``, and the "
"first two frames order ``1`` and ``2``."
msgstr ""

#: ../../asgi.rst:558
msgid ""
"If the protocol is datagram-based, one datagram should equal one ASGI "
"message (unless size is an issue)"
msgstr ""

#: ../../asgi.rst:563
msgid "Approximate Global Ordering"
msgstr "近似於全球訂購"

#: ../../asgi.rst:565
msgid ""
"While maintaining true global (across-channels) ordering of messages is "
"entirely unreasonable to expect of many implementations, they should "
"strive to prevent busy channels from overpowering quiet channels."
msgstr ""

#: ../../asgi.rst:569
msgid ""
"For example, imagine two channels, ``busy``, which spikes to 1000 "
"messages a second, and ``quiet``, which gets one message a second. "
"There's a single consumer running ``receive(['busy', 'quiet'])`` which "
"can handle around 200 messages a second."
msgstr ""

#: ../../asgi.rst:574
msgid ""
"In a simplistic for-loop implementation, the channel layer might always "
"check ``busy`` first; it always has messages available, and so the "
"consumer never even gets to see a message from ``quiet``, even if it was "
"sent with the first batch of ``busy`` messages."
msgstr ""

#: ../../asgi.rst:579
msgid ""
"A simple way to solve this is to randomize the order of the channel list "
"when looking for messages inside the channel layer; other, better methods"
" are also available, but whatever is chosen, it should try to avoid a "
"scenario where a message doesn't get received purely because another "
"channel is busy."
msgstr ""

#: ../../asgi.rst:586
msgid "Strings and Unicode"
msgstr "字串和 Unicode"

#: ../../asgi.rst:588
#, fuzzy
msgid ""
"In this document, and all sub-specifications, *byte string* refers to "
"``str`` on Python 2 and ``bytes`` on Python 3. If this type still "
"supports Unicode codepoints due to the underlying implementation, then "
"any values should be kept within the 0 - 255 range."
msgstr ""
"在此文件中，*byte string*是指Python 2上的“str”和Python "
"3上的“bytes”。如果由於底層實現，此類型仍然支持Unicode編輯碼，則任何值都應該在低於8個字元範圍。"

#: ../../asgi.rst:593
#, fuzzy
msgid ""
"*Unicode string* refers to ``unicode`` on Python 2 and ``str`` on Python "
"3. This document will never specify just *string* - all strings are one "
"of the two exact types."
msgstr ""
"* Unicode字串*是指Python 2上的“unicode”和Python 3上的“str”。這個文件永遠不會只指定* string * -"
" 所有的字串都是兩種類型的其中之一。"

#: ../../asgi.rst:597
msgid ""
"Some serializers, such as ``json``, cannot differentiate between byte "
"strings and unicode strings; these should include logic to box one type "
"as the other (for example, encoding byte strings as base64 unicode "
"strings with a preceding special character, e.g. U+FFFF)."
msgstr ""

#: ../../asgi.rst:602
msgid ""
"Channel and group names are always unicode strings, with the additional "
"limitation that they only use the following characters:"
msgstr "路徑和群組名稱皆為Unicode字串，且額外限制只使用以下文字："

#: ../../asgi.rst:605
msgid "ASCII letters"
msgstr "ASCII字母"

#: ../../asgi.rst:606
msgid "The digits ``0`` through ``9``"
msgstr "字元從\"0\"到\"9\""

#: ../../asgi.rst:607
msgid "Hyphen ``-``"
msgstr "連字號\"-\""

#: ../../asgi.rst:608
msgid "Underscore ``_``"
msgstr "底線\"_\""

#: ../../asgi.rst:609
msgid "Period ``.``"
msgstr "句號\".\""

#: ../../asgi.rst:610
msgid ""
"Question mark ``?`` (only to delineiate single-reader channel names, and "
"only one per name)"
msgstr "問號\"?\"(僅限於單讀者路徑名稱，且每個名稱限用一次)"

#: ../../asgi.rst:612
msgid ""
"Exclamation mark ``!`` (only to delineate process-specific channel names,"
" and only one per name)"
msgstr "驚嘆號\"!\"(僅描述特定於進行中的路徑名稱，且每個名稱限用一次)"

#: ../../asgi.rst:618
msgid "Common Questions"
msgstr "常見問題"

#: ../../asgi.rst:620
msgid "Why are messages ``dicts``, rather than a more advanced type?"
msgstr ""

#: ../../asgi.rst:622
msgid ""
"We want messages to be very portable, especially across process and "
"machine boundaries, and so a simple encodable type seemed the best way. "
"We expect frameworks to wrap each protocol-specific set of messages in "
"custom classes (e.g. ``http.request`` messages become ``Request`` "
"objects)"
msgstr "我們希望訊息方便編輯，特別在切換流程和機器介面，所以最好是一個簡單可編輯的類型。我們期望架構將包含每個特定協議訊息在各自定義類中(例如`http.request`訊息變`Request'物件)"

#: ../../asgi.rst:629
msgid "Copyright"
msgstr "版權"

#: ../../asgi.rst:631
msgid "This document has been placed in the public domain."
msgstr "此文件已放於公有領域"

#~ msgid ""
#~ "**NOTE: This is still in-progress, "
#~ "and may change substantially as "
#~ "development progresses.**"
#~ msgstr "**提醒：這部分仍在進行中，可能會依發展狀況有所變動。**"

#~ msgid ""
#~ "It is intended to supplement and "
#~ "expand on WSGI, though the design "
#~ "deliberately includes provisions to allow "
#~ "WSGI-to-ASGI and ASGI-to-WGSI "
#~ "adapters to be easily written for "
#~ "the HTTP protocol."
#~ msgstr ""

#~ msgid ""
#~ "The WSGI specification has worked well"
#~ " since it was introduced, and allowed"
#~ " for great flexibility in Python "
#~ "framework and webserver choice. However, "
#~ "its design is irrevocably tied to "
#~ "the HTTP-style request/response cycle, "
#~ "and more and more protocols are "
#~ "becoming a standard part of web "
#~ "programming that do not follow this "
#~ "pattern (most notably, WebSocket)."
#~ msgstr ""

#~ msgid ""
#~ "It also lays out new, serialization-"
#~ "compatible formats for things like HTTP"
#~ " requests and responses and WebSocket "
#~ "data frames, to allow these to be"
#~ " transported over a network or local"
#~ " memory, and allow separation of "
#~ "protocol handling and application logic "
#~ "into different processes."
#~ msgstr ""

#~ msgid ""
#~ "Despite the name of the proposal, "
#~ "ASGI does not specify or design to"
#~ " any specific in-process async "
#~ "solution, such as ``asyncio``, ``twisted``,"
#~ " or ``gevent``. Instead, the ``receive``"
#~ " function can be switched between "
#~ "nonblocking or synchronous. This approach "
#~ "allows applications to choose what's "
#~ "best for their current runtime "
#~ "environment; further improvements may provide"
#~ " extensions where cooperative versions of"
#~ " receive are provided."
#~ msgstr ""

#~ msgid ""
#~ "There is even room for a WSGI-"
#~ "like application abstraction with a "
#~ "callable which takes ``(channel, message, "
#~ "send_func)``, but this would be slightly"
#~ " too restrictive for many use cases"
#~ " and does not cover how to "
#~ "specify channel names to listen on; "
#~ "it is expected that frameworks will "
#~ "cover this use case."
#~ msgstr ""

#~ msgid "Integers (no longs)"
#~ msgstr "整數(無長整數)"

#~ msgid ""
#~ "*Process-specific channel* names contain "
#~ "an exclamation mark (``!``) character in"
#~ " order to indicate to the channel "
#~ "layer that it may have to route"
#~ " the data for these channels "
#~ "differently to ensure it reaches the "
#~ "single process that needs it; these "
#~ "channels are nearly always tied to "
#~ "incoming connections from the outside "
#~ "world. The ``!`` is always preceded "
#~ "by the main channel name (e.g. "
#~ "``http.response``) and followed by the "
#~ "per-client/random portion - channel layers"
#~ " can split on the ``!`` and use"
#~ " just the right hand part to "
#~ "route if they desire, or can "
#~ "ignore it if they don't need to"
#~ " use different routing rules. Even if"
#~ " the right hand side contains client"
#~ " routing information, it must still "
#~ "contain random parts too so that "
#~ "each call to ``new_channel`` returns a"
#~ " new, unused name. These names must"
#~ " be generated by the ``new_channel`` "
#~ "call; they are guaranteed to only "
#~ "be read from the same process that"
#~ " calls ``new_channel``."
#~ msgstr ""

#~ msgid ""
#~ "As such, this specification outlines "
#~ "encodings to and from ASGI messages "
#~ "for HTTP and WebSocket; this allows "
#~ "any ASGI web server to talk to "
#~ "any ASGI web application, as well "
#~ "as servers and applications for any "
#~ "other protocol with a common "
#~ "specification. It is recommended that if"
#~ " other protocols become commonplace they"
#~ " should gain standardized formats in "
#~ "a supplementary specification of their "
#~ "own."
#~ msgstr ""

#~ msgid ""
#~ "Solving this issue is left to "
#~ "frameworks and application code; there "
#~ "are already solutions such as database"
#~ " transactions that help solve this, "
#~ "and the vast majority of application "
#~ "code will not need to deal with"
#~ " this problem. If ordering of "
#~ "incoming packets matters for a protocol,"
#~ " they should be annotated with a "
#~ "packet number (as WebSocket is in "
#~ "this specification)."
#~ msgstr ""

#~ msgid ""
#~ "``receive(channels, block=False)``, a callable "
#~ "that takes a list of channel names"
#~ " as unicode strings, and returns with"
#~ " either ``(None, None)`` or ``(channel, "
#~ "message)`` if a message is available."
#~ " If ``block`` is True, then it "
#~ "will not return until after a "
#~ "built-in timeout or a message "
#~ "arrives; if ``block`` is false, it "
#~ "will always return immediately. It is"
#~ " perfectly valid to ignore ``block`` "
#~ "and always return immediately, or after"
#~ " a delay; ``block`` means that the"
#~ " call can take as long as it"
#~ " likes before returning a message or"
#~ " nothing, not that it must block "
#~ "until it gets one."
#~ msgstr ""

#~ msgid ""
#~ "``new_channel(pattern)``, a callable that "
#~ "takes a unicode string pattern, and "
#~ "returns a new valid channel name "
#~ "that does not already exist, by "
#~ "adding a unicode string after the "
#~ "``!`` or ``?`` character in ``pattern``,"
#~ " and checking for existence of that"
#~ " name in the channel layer. The "
#~ "``pattern`` MUST end with ``!`` or "
#~ "``?`` or this function must error. "
#~ "If the character is ``!``, making "
#~ "it a process-specific channel, "
#~ "``new_channel`` must be called on the"
#~ " same channel layer that intends to"
#~ " read the channel with ``receive``; "
#~ "any other channel layer instance may "
#~ "not receive messages on this channel "
#~ "due to client-routing portions of "
#~ "the appended string."
#~ msgstr ""

#~ msgid ""
#~ "``extensions``, a list of unicode string"
#~ " names indicating which extensions this "
#~ "layer provides, or empty if it "
#~ "supports none. The names defined in "
#~ "this document are ``groups``, ``flush`` "
#~ "and ``statistics``."
#~ msgstr ""

#~ msgid ""
#~ "A channel layer implementing the "
#~ "``asyncio`` extension must also provide:"
#~ msgstr ""

#~ msgid ""
#~ "``receive_asyncio(channels)``, a function that "
#~ "behaves like ``receive`` but that "
#~ "fulfills the asyncio coroutine contract "
#~ "to block until either a result is"
#~ " available or an internal timeout is"
#~ " reached and ``(None, None)`` is "
#~ "returned."
#~ msgstr ""

#~ msgid ""
#~ "These describe the standardized message "
#~ "formats for the protocols this "
#~ "specification supports. All messages are "
#~ "``dicts`` at the top level, and "
#~ "all keys are required unless otherwise"
#~ " specified (with a default to use "
#~ "if the key is missing). Keys are"
#~ " unicode strings."
#~ msgstr ""

#~ msgid "HTTP"
#~ msgstr ""

#~ msgid ""
#~ "The HTTP format covers HTTP/1.0, "
#~ "HTTP/1.1 and HTTP/2, as the changes "
#~ "in HTTP/2 are largely on the "
#~ "transport level. A protocol server "
#~ "should give different requests on the"
#~ " same connection different reply channels,"
#~ " and correctly multiplex the responses "
#~ "back into the same stream as they"
#~ " come in. The HTTP version is "
#~ "available as a string in the "
#~ "request message."
#~ msgstr ""

#~ msgid ""
#~ "HTTP/2 Server Push responses are "
#~ "included, but must be sent prior "
#~ "to the main response, and applications"
#~ " must check for ``http_version = 2``"
#~ " before sending them; if a protocol"
#~ " server or connection incapable of "
#~ "Server Push receives these, it must "
#~ "drop them."
#~ msgstr ""

#~ msgid ""
#~ "Multiple header fields with the same "
#~ "name are complex in HTTP. RFC 7230"
#~ " states that for any header field "
#~ "that can appear multiple times, it "
#~ "is exactly equivalent to sending that"
#~ " header field only once with all "
#~ "the values joined by commas."
#~ msgstr ""

#~ msgid ""
#~ "However, RFC 7230 and RFC 6265 "
#~ "make it clear that this rule does"
#~ " not apply to the various headers "
#~ "used by HTTP cookies (``Cookie`` and "
#~ "``Set-Cookie``). The ``Cookie`` header "
#~ "must only be sent once by a "
#~ "user-agent, but the ``Set-Cookie`` "
#~ "header may appear repeatedly and cannot"
#~ " be joined by commas. For this "
#~ "reason, we can safely make the "
#~ "request ``headers`` a ``dict``, but the"
#~ " response ``headers`` must be sent as"
#~ " a list of tuples, which matches "
#~ "WSGI."
#~ msgstr ""

#~ msgid "Request"
#~ msgstr ""

#~ msgid ""
#~ "Sent once for each request that "
#~ "comes into the protocol server. If "
#~ "sending this raises ``ChannelFull``, the "
#~ "interface server must respond with a "
#~ "500-range error, preferably ``503 Service "
#~ "Unavailable``, and close the connection."
#~ msgstr ""

#~ msgid "Channel: ``http.request``"
#~ msgstr ""

#~ msgid "Keys:"
#~ msgstr ""

#~ msgid ""
#~ "``reply_channel``: Channel name for responses"
#~ " and server pushes, starting with "
#~ "``http.response!``"
#~ msgstr ""

#~ msgid "``http_version``: Unicode string, one of ``1.0``, ``1.1`` or ``2``."
#~ msgstr ""

#~ msgid "``method``: Unicode string HTTP method name, uppercased."
#~ msgstr ""

#~ msgid ""
#~ "``scheme``: Unicode string URL scheme "
#~ "portion (likely ``http`` or ``https``). "
#~ "Optional (but must not be empty), "
#~ "default is ``\"http\"``."
#~ msgstr ""

#~ msgid ""
#~ "``path``: Unicode string HTTP path from"
#~ " URL, with percent escapes decoded "
#~ "and UTF8 byte sequences decoded into "
#~ "characters."
#~ msgstr ""

#~ msgid ""
#~ "``query_string``: Byte string URL portion "
#~ "after the ``?``, not url-decoded."
#~ msgstr ""

#~ msgid ""
#~ "``root_path``: Unicode string that indicates"
#~ " the root path this application is"
#~ " mounted at; same as ``SCRIPT_NAME`` "
#~ "in WSGI. Optional, defaults to ``\"\"``."
#~ msgstr ""

#~ msgid ""
#~ "``headers``: A list of ``[name, value]``"
#~ " pairs, where ``name`` is the byte"
#~ " string header name, and ``value`` is"
#~ " the byte string header value. Order"
#~ " should be preserved from the "
#~ "original HTTP request; duplicates are "
#~ "possible and must be preserved in "
#~ "the message as received. Header names"
#~ " must be lowercased."
#~ msgstr ""

#~ msgid ""
#~ "``body``: Body of the request, as "
#~ "a byte string. Optional, defaults to "
#~ "``\"\"``. If ``body_channel`` is set, "
#~ "treat as start of body and "
#~ "concatenate on further chunks."
#~ msgstr ""

#~ msgid ""
#~ "``body_channel``: Name of a single-"
#~ "reader channel (containing ``?``) that "
#~ "contains Request Body Chunk messages "
#~ "representing a large request body. "
#~ "Optional, defaults to ``None``. Chunks "
#~ "append to ``body`` if set. Presence "
#~ "of a channel indicates at least "
#~ "one Request Body Chunk message needs "
#~ "to be read, and then further "
#~ "consumption keyed off of the "
#~ "``more_content`` key in those messages."
#~ msgstr ""

#~ msgid ""
#~ "``client``: List of ``[host, port]`` "
#~ "where ``host`` is a unicode string "
#~ "of the remote host's IPv4 or IPv6"
#~ " address, and ``port`` is the remote"
#~ " port as an integer. Optional, "
#~ "defaults to ``None``."
#~ msgstr ""

#~ msgid ""
#~ "``server``: List of ``[host, port]`` "
#~ "where ``host`` is the listening address"
#~ " for this server as a unicode "
#~ "string, and ``port`` is the integer "
#~ "listening port. Optional, defaults to "
#~ "``None``."
#~ msgstr ""

#~ msgid "Request Body Chunk"
#~ msgstr ""

#~ msgid ""
#~ "Must be sent after an initial "
#~ "Response. If trying to send this "
#~ "raises ``ChannelFull``, the interface server"
#~ " should wait and try again until "
#~ "it is accepted (the consumer at "
#~ "the other end of the channel may"
#~ " not be as fast consuming the "
#~ "data as the client is at sending"
#~ " it)."
#~ msgstr ""

#~ msgid "Channel: ``http.request.body?``"
#~ msgstr ""

#~ msgid ""
#~ "``content``: Byte string of HTTP body"
#~ " content, will be concatenated onto "
#~ "previously received ``content`` values and "
#~ "``body`` key in Request. Not required"
#~ " if ``closed`` is True, required "
#~ "otherwise."
#~ msgstr ""

#~ msgid ""
#~ "``closed``: True if the client closed"
#~ " the connection prematurely and the "
#~ "rest of the body. If you receive"
#~ " this, abandon processing of the HTTP"
#~ " request. Optional, defaults to ``False``."
#~ msgstr ""

#~ msgid ""
#~ "``more_content``: Boolean value signifying if"
#~ " there is additional content to come"
#~ " (as part of a Request Body "
#~ "Chunk message). If ``False``, request "
#~ "will be taken as complete, and any"
#~ " further messages on the channel will"
#~ " be ignored. Optional, defaults to "
#~ "``False``."
#~ msgstr ""

#~ msgid "Response"
#~ msgstr "回應"

#~ msgid ""
#~ "Send after any server pushes, and "
#~ "before any response chunks. If "
#~ "``ChannelFull`` is encountered, wait and "
#~ "try again later, optionally giving up"
#~ " after a predetermined timeout."
#~ msgstr ""

#~ msgid "Channel: ``http.response!``"
#~ msgstr ""

#~ msgid "``status``: Integer HTTP status code."
#~ msgstr ""

#~ msgid ""
#~ "``headers``: A list of ``[name, value]``"
#~ " pairs, where ``name`` is the byte"
#~ " string header name, and ``value`` is"
#~ " the byte string header value. Order"
#~ " should be preserved in the HTTP "
#~ "response. Header names must be "
#~ "lowercased."
#~ msgstr ""

#~ msgid ""
#~ "``content``: Byte string of HTTP body"
#~ " content. Optional, defaults to empty "
#~ "string."
#~ msgstr ""

#~ msgid ""
#~ "``more_content``: Boolean value signifying if"
#~ " there is additional content to come"
#~ " (as part of a Response Chunk "
#~ "message). If ``False``, response will be"
#~ " taken as complete and closed off,"
#~ " and any further messages on the "
#~ "channel will be ignored. Optional, "
#~ "defaults to ``False``."
#~ msgstr ""

#~ msgid "Response Chunk"
#~ msgstr ""

#~ msgid ""
#~ "Must be sent after an initial "
#~ "Response. If ``ChannelFull`` is encountered,"
#~ " wait and try again later."
#~ msgstr ""

#~ msgid ""
#~ "``content``: Byte string of HTTP body"
#~ " content, will be concatenated onto "
#~ "previously received ``content`` values."
#~ msgstr ""

#~ msgid "Server Push"
#~ msgstr ""

#~ msgid ""
#~ "Must be sent before any Response "
#~ "or Response Chunk messages. If "
#~ "``ChannelFull`` is encountered, wait and "
#~ "try again later, optionally giving up"
#~ " after a predetermined timeout, and "
#~ "give up on the entire response "
#~ "this push is connected to."
#~ msgstr ""

#~ msgid ""
#~ "When a server receives this message, "
#~ "it must treat the Request message "
#~ "in the ``request`` field of the "
#~ "Server Push as though it were a"
#~ " new HTTP request being received from"
#~ " the network. A server may, if "
#~ "it chooses, apply all of its "
#~ "internal logic to handling this request"
#~ " (e.g. the server may want to "
#~ "try to satisfy the request from a"
#~ " cache). Regardless, if the server is"
#~ " unable to satisfy the request itself"
#~ " it must create a new "
#~ "``http.response!`` channel for the application"
#~ " to send the Response message on, "
#~ "fill that channel in on the "
#~ "``reply_channel`` field of the message, "
#~ "and then send the Request back to"
#~ " the application on the ``http.request``"
#~ " channel."
#~ msgstr ""

#~ msgid ""
#~ "This approach limits the amount of "
#~ "knowledge the application has to have"
#~ " about pushed responses: they essentially"
#~ " appear to the application like a "
#~ "normal HTTP request, with the difference"
#~ " being that the application itself "
#~ "triggered the request."
#~ msgstr ""

#~ msgid ""
#~ "If the remote peer does not "
#~ "support server push, either because it's"
#~ " not a HTTP/2 peer or because "
#~ "SETTINGS_ENABLE_PUSH is set to 0, the"
#~ " server must do nothing in response"
#~ " to this message."
#~ msgstr ""

#~ msgid ""
#~ "``request``: A Request message. The "
#~ "``body``, ``body_channel``, and ``reply_channel``"
#~ " fields MUST be absent: bodies are"
#~ " not allowed on server-pushed "
#~ "requests, and applications should not "
#~ "create reply channels."
#~ msgstr ""

#~ msgid "Disconnect"
#~ msgstr "取消連結"

#~ msgid ""
#~ "Sent when a HTTP connection is "
#~ "closed. This is mainly useful for "
#~ "long-polling, where you may have "
#~ "added the response channel to a "
#~ "Group or other set of channels you"
#~ " want to trigger a reply to "
#~ "when data arrives."
#~ msgstr ""

#~ msgid ""
#~ "If ``ChannelFull`` is raised, then give"
#~ " up attempting to send the message;"
#~ " consumption is not required."
#~ msgstr ""

#~ msgid "Channel: ``http.disconnect``"
#~ msgstr ""

#~ msgid ""
#~ "``reply_channel``: Channel name responses "
#~ "would have been sent on. No longer"
#~ " valid after this message is sent;"
#~ " all messages to it will be "
#~ "dropped."
#~ msgstr ""

#~ msgid "WebSocket"
#~ msgstr ""

#~ msgid ""
#~ "WebSockets share some HTTP details - "
#~ "they have a path and headers - "
#~ "but also have more state. Path and"
#~ " header details are only sent in "
#~ "the connection message; applications that "
#~ "need to refer to these during "
#~ "later messages should store them in "
#~ "a cache or database."
#~ msgstr ""

#~ msgid ""
#~ "WebSocket protocol servers should handle "
#~ "PING/PONG requests themselves, and send "
#~ "PING frames as necessary to ensure "
#~ "the connection is alive."
#~ msgstr ""

#~ msgid ""
#~ "Note that you **must** ensure that "
#~ "websocket.connect is consumed; if an "
#~ "interface server gets ``ChannelFull`` on "
#~ "this channel it will drop the "
#~ "connection. Django Channels ships with a"
#~ " no-op consumer attached by default;"
#~ " we recommend other implementations do "
#~ "the same."
#~ msgstr ""

#~ msgid "Connection"
#~ msgstr "連結"

#~ msgid ""
#~ "Sent when the client initially opens "
#~ "a connection and completes the WebSocket"
#~ " handshake. If sending this raises "
#~ "``ChannelFull``, the interface server must "
#~ "close the connection with either HTTP"
#~ " status code ``503`` or WebSocket "
#~ "close code ``1013``."
#~ msgstr ""

#~ msgid ""
#~ "This message must be responded to "
#~ "on the ``reply_channel`` with a "
#~ "*Send/Close/Accept* message before the socket"
#~ " will pass messages on the "
#~ "``receive`` channel. The protocol server "
#~ "should ideally send this message during"
#~ " the handshake phase of the WebSocket"
#~ " and not complete the handshake until"
#~ " it gets a reply, returning HTTP "
#~ "status code ``403`` if the connection"
#~ " is denied. If this is not "
#~ "possible, it must buffer WebSocket "
#~ "frames and not send them onto "
#~ "``websocket.receive`` until a reply is "
#~ "received, and if the connection is "
#~ "rejected, return WebSocket close code "
#~ "``4403``."
#~ msgstr ""

#~ msgid "Channel: ``websocket.connect``"
#~ msgstr ""

#~ msgid ""
#~ "``reply_channel``: Channel name for sending"
#~ " data, start with ``websocket.send!``"
#~ msgstr ""

#~ msgid ""
#~ "``scheme``: Unicode string URL scheme "
#~ "portion (likely ``ws`` or ``wss``). "
#~ "Optional (but must not be empty), "
#~ "default is ``ws``."
#~ msgstr ""

#~ msgid "``path``: Unicode HTTP path from URL, already urldecoded."
#~ msgstr ""

#~ msgid ""
#~ "``query_string``: Byte string URL portion "
#~ "after the ``?``. Optional, default is"
#~ " empty string."
#~ msgstr ""

#~ msgid ""
#~ "``root_path``: Byte string that indicates "
#~ "the root path this application is "
#~ "mounted at; same as ``SCRIPT_NAME`` in"
#~ " WSGI. Optional, defaults to empty "
#~ "string."
#~ msgstr ""

#~ msgid ""
#~ "``headers``: List of ``[name, value]``, "
#~ "where ``name`` is the header name "
#~ "as byte string and ``value`` is "
#~ "the header value as a byte string."
#~ " Order should be preserved from the"
#~ " original HTTP request; duplicates are "
#~ "possible and must be preserved in "
#~ "the message as received. Header names"
#~ " must be lowercased."
#~ msgstr ""

#~ msgid "``order``: The integer value ``0``."
#~ msgstr "``order``: 整數值為 ``0``。"

#~ msgid "Receive"
#~ msgstr "接收"

#~ msgid ""
#~ "Sent when a data frame is received"
#~ " from the client. If ``ChannelFull`` "
#~ "is raised, you may retry sending "
#~ "it but if it does not send "
#~ "the socket must be closed with "
#~ "websocket error code 1013."
#~ msgstr ""

#~ msgid "Channel: ``websocket.receive``"
#~ msgstr ""

#~ msgid ""
#~ "``reply_channel``: Channel name for sending"
#~ " data, starting with ``websocket.send!``"
#~ msgstr ""

#~ msgid ""
#~ "``path``: Path sent during ``connect``, "
#~ "sent to make routing easier for "
#~ "apps."
#~ msgstr ""

#~ msgid ""
#~ "``bytes``: Byte string of frame content,"
#~ " if it was bytes mode, or "
#~ "``None``."
#~ msgstr ""

#~ msgid ""
#~ "``text``: Unicode string of frame "
#~ "content, if it was text mode, or"
#~ " ``None``."
#~ msgstr ""

#~ msgid ""
#~ "``order``: Order of this frame in "
#~ "the WebSocket stream, starting at 1 "
#~ "(``connect`` is 0)."
#~ msgstr ""

#~ msgid "One of ``bytes`` or ``text`` must be non-``None``."
#~ msgstr ""

#~ msgid "Disconnection"
#~ msgstr "無法連接"

#~ msgid ""
#~ "Sent when either connection to the "
#~ "client is lost, either from the "
#~ "client closing the connection, the "
#~ "server closing the connection, or loss"
#~ " of the socket."
#~ msgstr ""

#~ msgid "Channel: ``websocket.disconnect``"
#~ msgstr ""

#~ msgid ""
#~ "``reply_channel``: Channel name that was "
#~ "used for sending data, starting with "
#~ "``websocket.send!``. Cannot be used to "
#~ "send at this point; provided as a"
#~ " way to identify the connection only."
#~ msgstr ""

#~ msgid ""
#~ "``code``: The WebSocket close code "
#~ "(integer), as per the WebSocket spec."
#~ msgstr ""

#~ msgid ""
#~ "``order``: Order of the disconnection "
#~ "relative to the incoming frames' "
#~ "``order`` values in ``websocket.receive``."
#~ msgstr ""

#~ msgid "Send/Close/Accept"
#~ msgstr ""

#~ msgid ""
#~ "Sends a data frame to the client"
#~ " and/or closes the connection from "
#~ "the server end and/or accepts a "
#~ "connection. If ``ChannelFull`` is raised, "
#~ "wait and try again."
#~ msgstr ""

#~ msgid ""
#~ "If received while the connection is "
#~ "waiting for acceptance after a "
#~ "``connect`` message:"
#~ msgstr ""

#~ msgid ""
#~ "If ``bytes`` or ``text`` is present, "
#~ "accept the connection and send the "
#~ "data."
#~ msgstr ""

#~ msgid "If ``accept`` is ``True``, accept the connection and do nothing else."
#~ msgstr "如果 ``accept`` 是 ``True``，接受連接，然後不做任何事情。"

#~ msgid ""
#~ "If ``close`` is ``True`` or a "
#~ "positive integer, reject the connection. "
#~ "If ``bytes`` or ``text`` is also "
#~ "set, it should accept the connection,"
#~ " send the frame, then immediately "
#~ "close the connection."
#~ msgstr ""

#~ msgid "If received while the connection is established:"
#~ msgstr "如果在建立連接時接收到:"

#~ msgid "If ``bytes`` or ``text`` is present, send the data."
#~ msgstr ""

#~ msgid ""
#~ "If ``close`` is ``True`` or a "
#~ "positive integer, close the connection "
#~ "after any send."
#~ msgstr ""

#~ msgid "``accept`` is ignored."
#~ msgstr "``accept`` 是被忽略的。"

#~ msgid "Channel: ``websocket.send!``"
#~ msgstr ""

#~ msgid "``bytes``: Byte string of frame content, if in bytes mode, or ``None``."
#~ msgstr ""

#~ msgid ""
#~ "``text``: Unicode string of frame "
#~ "content, if in text mode, or "
#~ "``None``."
#~ msgstr ""

#~ msgid ""
#~ "``close``: Boolean indicating if the "
#~ "connection should be closed after data"
#~ " is sent, if any. Alternatively, a"
#~ " positive integer specifying the response"
#~ " code. The response code will be "
#~ "1000 if you pass ``True``. Optional, "
#~ "default ``False``."
#~ msgstr ""

#~ msgid ""
#~ "``accept``: Boolean saying if the "
#~ "connection should be accepted without "
#~ "sending a frame if it is in "
#~ "the handshake phase."
#~ msgstr ""

#~ msgid ""
#~ "A maximum of one of ``bytes`` or"
#~ " ``text`` may be provided. If both"
#~ " are provided, the protocol server "
#~ "should ignore the message entirely."
#~ msgstr "最多可以提供一個 ``bytes`` 或 ``text``。若同時提供兩者，伺服器應該會忽略該訊息。"

#~ msgid "WSGI Compatibility"
#~ msgstr ""

#~ msgid ""
#~ "Part of the design of the HTTP "
#~ "portion of this spec is to make"
#~ " sure it aligns well with the "
#~ "WSGI specification, to ensure easy "
#~ "adaptability between both specifications and"
#~ " the ability to keep using WSGI "
#~ "servers or applications with ASGI."
#~ msgstr ""

#~ msgid "The adaptability works in two ways:"
#~ msgstr ""

#~ msgid ""
#~ "WSGI Server to ASGI: A WSGI "
#~ "application can be written that "
#~ "transforms ``environ`` into a Request "
#~ "message, sends it off on the "
#~ "``http.request`` channel, and then waits "
#~ "on a generated response channel for "
#~ "a Response message. This has the "
#~ "disadvantage of tying up an entire "
#~ "WSGI thread to poll one channel, "
#~ "but should not be a massive "
#~ "performance drop if there is no "
#~ "backlog on the request channel, and "
#~ "would work fine for an in-process"
#~ " adapter to run a pure-ASGI web"
#~ " application."
#~ msgstr ""

#~ msgid ""
#~ "ASGI to WSGI application: A small "
#~ "wrapper process is needed that listens"
#~ " on the ``http.request`` channel, and "
#~ "decodes incoming Request messages into "
#~ "an ``environ`` dict that matches the "
#~ "WSGI specs, while passing in a "
#~ "``start_response`` that stores the values "
#~ "for sending with the first content "
#~ "chunk. Then, the application iterates "
#~ "over the WSGI app, packaging each "
#~ "returned content chunk into a Response"
#~ " or Response Chunk message (if more"
#~ " than one is yielded)."
#~ msgstr ""

#~ msgid ""
#~ "There is an almost direct mapping "
#~ "for the various special keys in "
#~ "WSGI's ``environ`` variable to the "
#~ "Request message:"
#~ msgstr ""

#~ msgid "``REQUEST_METHOD`` is the ``method`` key"
#~ msgstr "\"REQUEST_METHOD\"是\"功能\"鍵"

#~ msgid "``SCRIPT_NAME`` is ``root_path``"
#~ msgstr "\"SCRIPT_NAME\"是\"脈絡路徑\""

#~ msgid "``PATH_INFO`` can be derived from ``path`` and ``root_path``"
#~ msgstr ""

#~ msgid "``QUERY_STRING`` is ``query_string``"
#~ msgstr ""

#~ msgid "``CONTENT_TYPE`` can be extracted from ``headers``"
#~ msgstr ""

#~ msgid "``CONTENT_LENGTH`` can be extracted from ``headers``"
#~ msgstr ""

#~ msgid "``SERVER_NAME`` and ``SERVER_PORT`` are in ``server``"
#~ msgstr ""

#~ msgid "``REMOTE_HOST``/``REMOTE_ADDR`` and ``REMOTE_PORT`` are in ``client``"
#~ msgstr ""

#~ msgid "``SERVER_PROTOCOL`` is encoded in ``http_version``"
#~ msgstr ""

#~ msgid "``wsgi.url_scheme`` is ``scheme``"
#~ msgstr ""

#~ msgid "``wsgi.input`` is a StringIO around ``body``"
#~ msgstr ""

#~ msgid "``wsgi.errors`` is directed by the wrapper as needed"
#~ msgstr ""

#~ msgid "The ``start_response`` callable maps similarly to Response:"
#~ msgstr ""

#~ msgid ""
#~ "The ``status`` argument becomes ``status``,"
#~ " with the reason phrase dropped."
#~ msgstr ""

#~ msgid "``response_headers`` maps to ``headers``"
#~ msgstr ""

#~ msgid ""
#~ "It may even be possible to map "
#~ "Request Body Chunks in a way that"
#~ " allows streaming of body data, "
#~ "though it would likely be easier "
#~ "and sufficient for many applications to"
#~ " simply buffer the whole body into"
#~ " memory before calling the WSGI "
#~ "application."
#~ msgstr ""

#~ msgid "TODOs"
#~ msgstr ""

#~ msgid ""
#~ "Maybe remove ``http_version`` and replace "
#~ "with ``supports_server_push``?"
#~ msgstr "可移除``http_version``並換成`supports_server_push``?"

#~ msgid ""
#~ "``receive`` can't easily be implemented "
#~ "with async/cooperative code behind it as"
#~ " it's nonblocking - possible alternative"
#~ " call type? Asyncio extension that "
#~ "provides ``receive_yield``?"
#~ msgstr ""

#~ msgid ""
#~ "Possible extension to allow detection of"
#~ " channel layer flush/restart and prompt "
#~ "protocol servers to restart?"
#~ msgstr ""

#~ msgid ""
#~ "Maybe WSGI-app like spec for "
#~ "simple \"applications\" that allows "
#~ "standardized application-running servers?"
#~ msgstr ""

#~ msgid "Protocol Definitions"
#~ msgstr ""

