# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, test
# This file is distributed under the same license as the test package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: test 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-06-21 02:56+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Jason <chairco@gmail.com>, 2017\n"
"Language: zh_Hant_TW\n"
"Language-Team: Chinese (Taiwan) (https://www.transifex.com/django-"
"channels-tw-docs/teams/72101/zh_TW/)\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../backends.rst:2
msgid "Channel Layer Types"
msgstr "通道層類型"

#: ../../backends.rst:4
msgid ""
"Multiple choices of backend are available, to fill different tradeoffs of"
" complexity, throughput and scalability. You can also write your own "
"backend if you wish; the spec they confirm to is called :doc:`ASGI "
"<asgi>`. Any ASGI-compliant channel layer can be used."
msgstr ""
"可以選擇多種後端，以滿足複雜性，吞吐量和可擴展性的不同折衷。你也可以寫你自己的後端，如果你願意；他們確認的規範被稱為 :doc:`ASGI "
"<asgi>`。可以使用任何符合ASGI的信道層。"

#: ../../backends.rst:10
msgid "Redis"
msgstr "Redis"

#: ../../backends.rst:12
msgid ""
"The Redis layer is the recommended backend to run Channels with, as it "
"supports both high throughput on a single Redis server as well as the "
"ability to run against a set of Redis servers in a sharded mode."
msgstr ""
"Redis 層是運行 Channels 的推薦後端，因為它支持單個 Redis 服務器上的高吞吐量以及在分片模式下對一組 Redis "
"服務器運行的能力。"

#: ../../backends.rst:16
msgid ""
"To use the Redis layer, simply install it from PyPI (it lives in a "
"separate package, as we didn't want to force a dependency on the redis-py"
" for the main install)::"
msgstr "要使用 Redis 層，只需從 PyPI 安裝它 (它放在一個單獨的包，因為我們不想強制依賴於 redis-py 主安裝)::"

#: ../../backends.rst:22
msgid ""
"By default, it will attempt to connect to a Redis server on "
"``localhost:6379``, but you can override this with the ``hosts`` key in "
"its config::"
msgstr ""
"默認情況下，它將嘗試連接到 ``localhost:6379`` 的 Redis 服務器，但是你可以用 ``hosts`` 再複寫它的 "
"config::"

#: ../../backends.rst:36
msgid "Sharding"
msgstr "分片"

#: ../../backends.rst:38
msgid ""
"The sharding model is based on consistent hashing - in particular, "
":ref:`response channels <channel-types>` are hashed and used to pick a "
"single Redis server that both the interface server and the worker will "
"use."
msgstr ""
"分片模型基於一致性散列 - 特別是 :ref:`response channels <channel-types>` 被散列，用於選擇接口服務器和"
" worker 都將使用的單個 Redis 服務器。"

#: ../../backends.rst:42
msgid ""
"For normal channels, since any worker can service any channel request, "
"messages are simply distributed randomly among all possible servers, and "
"workers will pick a single server to listen to. Note that if you run more"
" Redis servers than workers, it's very likely that some servers will not "
"have workers listening to them; we recommend you always have at least ten"
" workers for each Redis server to ensure good distribution. Workers will,"
" however, change server periodically (every five seconds or so) so queued"
" messages should eventually get a response."
msgstr ""
"對於正常信道，由於任何工作者都可以服務任何信道請求，所以消息簡單地在所有可能的服務器之間分佈，工作者將選擇單個服務器來收聽。注意，如果你運行的 "
"Redis 服務器比 worker 多，很可能有些服務器沒有工作線程監聽它們;我們建議您始終為每個 Redis "
"服務器至少有十個工作線程，以確保良好的分發。然而，工作者將定期（每五秒左右）改變服務器，因此排隊的消息應該最終得到響應。"

#: ../../backends.rst:50
msgid ""
"Note that if you change the set of sharding servers you will need to "
"restart all interface servers and workers with the new set before "
"anything works, and any in-flight messages will be lost (even with "
"persistence, some will); the consistent hashing model relies on all "
"running clients having the same settings. Any misconfigured interface "
"server or worker will drop some or all messages."
msgstr "請注意，如果更改分片服務器集，您需要在任何工作之前重新啟動所有接口服務器和具有新集的工作線程，並且任何正在傳輸的消息都將丟失（即使有持久性，也會有）。一致性哈希模型依賴於具有相同設置的所有運行的客戶端。任何配置錯誤的接口服務器或工作程序將刪除部分或全部消息。"

#: ../../backends.rst:58
msgid "RabbitMQ"
msgstr ""

#: ../../backends.rst:60
msgid ""
"RabbitMQ layer is comparable to Redis in terms of latency and throughput."
"  It can work with single RabbitMQ node and with Erlang cluster."
msgstr ""

#: ../../backends.rst:64
msgid "You need to install layer package from PyPI::"
msgstr ""

#: ../../backends.rst:68
msgid ""
"To use it you also need provide link to the virtual host with granted "
"permissions::"
msgstr ""

#: ../../backends.rst:81
msgid ""
"This layer has complete `documentation <http://asgi-"
"rabbitmq.readthedocs.io/en/latest/>`_ on its own."
msgstr ""

#: ../../backends.rst:84
msgid "IPC"
msgstr "IPC"

#: ../../backends.rst:86
msgid ""
"The IPC backend uses POSIX shared memory segments and semaphores in order"
" to allow different processes on the same machine to communicate with "
"each other."
msgstr "IPC 後端使用 POSIX 共享內存段和信號量，以允許同一機器上的不同進程相互通信。"

#: ../../backends.rst:89
msgid ""
"As it uses shared memory, it does not require any additional servers "
"running to get working, and is quicker than any network-based channel "
"layer. However, it can only run between processes on the same machine."
msgstr "由於它使用共享內存，它不需要任何額外的服務器運行來工作，並且快於任何基於網絡的通道層。但是，它只能在同一台機器上的進程之間運行。"

#: ../../backends.rst:94
msgid ""
"The IPC layer only communicates between processes on the same machine, "
"and while you might initially be tempted to run a cluster of machines all"
" with their own IPC-based set of processes, this will result in groups "
"not working properly; events sent to a group will only go to those "
"channels that joined the group on the same machine. This backend is for "
"single-machine deployments only."
msgstr ""
"IPC "
"層只在同一台機器上的進程之間進行通信，雖然最初可能會試圖運行一組具有自己的基於IPC的進程集合的機器，但這會導致組無法正常工作;發送到群組的事件將只會轉到在同一台計算機上加入群組的那些頻道。此後端僅用於單機部署。"

#: ../../backends.rst:103
msgid "In-memory"
msgstr "In-memory"

#: ../../backends.rst:105
msgid ""
"The in-memory layer is only useful when running the protocol server and "
"the worker server in a single process; the most common case of this is "
"``runserver``, where a server thread, this channel layer, and worker "
"thread all co-exist inside the same python process."
msgstr ""
"in-memory "
"層僅在單個進程中運行協議服務器和工作服務器時有用;最常見的情況是``runserver``，其中服務器線程，這個通道層和工作線程都在同一個 "
"python 進程內共存。"

#: ../../backends.rst:110
msgid ""
"Its path is ``asgiref.inmemory.ChannelLayer``. If you try and use this "
"channel layer with ``runworker``, it will exit, as it does not support "
"cross-process communication."
msgstr "它的路徑是``asgiref.inmemory.ChannelLayer``。如果你嘗試和``runworker``使用這個通道層，它將退出，因為它不支持跨進程通信。"

#: ../../backends.rst:116
msgid "Writing Custom Channel Layers"
msgstr "編寫自定義通道層"

#: ../../backends.rst:118
msgid ""
"The interface channel layers present to Django and other software that "
"communicates over them is codified in a specification called :doc:`ASGI "
"<asgi>`."
msgstr ""

#: ../../backends.rst:121
msgid ""
"Any channel layer that conforms to the :doc:`ASGI spec <asgi>` can be "
"used by Django; just set ``BACKEND`` to the class to instantiate and "
"``CONFIG`` to a dict of keyword arguments to initialize the class with."
msgstr ""

