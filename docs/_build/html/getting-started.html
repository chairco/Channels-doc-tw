<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_TW">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Getting Started with Channels &#8212; Channels-docs-zhTW 1.1.5 說明文件</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜尋" href="search.html" />
    <link rel="next" title="部署" href="deploying.html" />
    <link rel="prev" title="安裝" href="installation.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="deploying.html" title="部署"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="installation.html" title="安裝"
             accesskey="P">上一頁</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Channels-docs-zhTW 1.1.5 說明文件</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="getting-started-with-channels">
<h1>Getting Started with Channels<a class="headerlink" href="#getting-started-with-channels" title="本標題的永久連結">¶</a></h1>
<p>(If you haven&#8217;t yet, make sure you <a class="reference internal" href="installation.html"><span class="doc">install Channels</span></a>)</p>
<p>現在，讓我們開始寫一些 consumer。假如尚未讀過 <a class="reference internal" href="concepts.html"><span class="doc">Channels 的概念</span></a> 先研讀過後，它包含最基礎的像是那些是 channels 與群組、重要的實施模式佈局與注意事項。</p>
<div class="section" id="first-consumers">
<h2>First Consumers<a class="headerlink" href="#first-consumers" title="本標題的永久連結">¶</a></h2>
<p>當你第一次執行 Django 並安裝 Channels，將會設定默認的 layout - 所有的 HTTP requests (在 <code class="docutils literal"><span class="pre">http.request</span></code> channel) 如何路由到 Django - 與過去基於 WSGI-based Django 與你的視覺圖與靜態檔案服務 (依然運作如一般 <code class="docutils literal"><span class="pre">runserver</span></code> 不會有任何的不同)</p>
<p>做為一個非常基礎的介紹，我們即將撰寫一個 consumer 覆寫的內置處理器，直接處理每一個 HTTP request 的需求。你不會經常在專案內這樣做，但是這很棒的說明 channels 如何成為 Django 的核心 - 他不是增加一個新的 addition 而是一個全新的 layer 建築在既有的視圖 view 上。</p>
<p>現在，建一個新的專案以及一個新的 app， 並將這些放到一個 app:: 裡的 <code class="docutils literal"><span class="pre">consumers.py</span></code> 檔案。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.http</span> <span class="k">import</span> <span class="n">HttpResponse</span>
<span class="kn">from</span> <span class="nn">channels.handler</span> <span class="k">import</span> <span class="n">AsgiHandler</span>

<span class="k">def</span> <span class="nf">http_consumer</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Make standard HTTP response - access ASGI path attribute directly</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="s2">&quot;Hello world! You asked for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span>
    <span class="c1"># Encode that response into message format (ASGI)</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">AsgiHandler</span><span class="o">.</span><span class="n">encode_response</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
        <span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p>在這裡很重要且必須注意的事，因為我們送出的訊息必須是 JSON 可序列化，這個 request 與 response 訊息是一組鍵值對的形式。你可以讀取更多關於這些格式在 <a class="reference internal" href="asgi.html"><span class="doc">ASGI specification</span></a>， 但不需要擔心太多;只需要知道這些是一個 <code class="docutils literal"><span class="pre">AsgiRequest</span></code> class 用來轉換 ASGI 到 Django request 物件，<code class="docutils literal"><span class="pre">AsgiHandler</span></code> class 負責轉換 <code class="docutils literal"><span class="pre">HttpResponse</span></code> 進入 ASGI 訊息，這一切就如你所見到上面使用的。通常當你使用一般的視圖時，Django 的內置處理器程式碼將會完成這些。</p>
<p>現在我們需要再做一件事，那就是告訴 Django 這是 Consumer 應該要被綁定在 <code class="docutils literal"><span class="pre">http.request</span></code> channel 而不是 Django 預設的視圖系統。這透過修改 settings 檔案完成 - 較為特別是我們需要定義我們的 <code class="docutils literal"><span class="pre">預設</span></code> channel layer 和路由設置。</p>
<p>Channel 路由有點像是 URL 路由，因此它的結構類似 - 你透過  dict 指定這個映射的設定，映射 channels 到 Consumer 的可調用。他的樣子會像是:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In settings.py</span>
<span class="n">CHANNEL_LAYERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;BACKEND&quot;</span><span class="p">:</span> <span class="s2">&quot;asgiref.inmemory.ChannelLayer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ROUTING&quot;</span><span class="p">:</span> <span class="s2">&quot;myproject.routing.channel_routing&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In routing.py</span>
<span class="kn">from</span> <span class="nn">channels.routing</span> <span class="k">import</span> <span class="n">route</span>
<span class="n">channel_routing</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;http.request&quot;</span><span class="p">,</span> <span class="s2">&quot;myapp.consumers.http_consumer&quot;</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">這裡的範例，和大部分這邊的範例，使用 &#8220;In memory&#8221; channel layer。這是簡單的開始與提供絕對沒有跨進程的通道傳輸，所以只能使用在 <code class="docutils literal"><span class="pre">runserver</span></code> 環境下。在佈署環境下，你需要選擇另一個後端 (稍後討論) 來運行。</p>
</div>
<p>如你所見，這有點像是 Django 的 <code class="docutils literal"><span class="pre">DATABASES</span></code> 設定; 被命名的 channel layers 有個預設通道被命名為 <code class="docutils literal"><span class="pre">default</span></code>。 每一個 layer 需要一個 channel layer 類別，一些選項 ( 假如 channel layer 需要他們的話 ) 以及然後一個路由方案，其指向包含路由設置的列表。建議你在項目中稱這個檔案為 <code class="docutils literal"><span class="pre">routing.py</span></code> 並把它和 <code class="docutils literal"><span class="pre">urls.py</span></code> 放在一起，但是只要路徑是正確的，你可以把它放在任何你喜歡的地方。</p>
<p>假如你透過 <code class="docutils literal"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">runserver</span></code> 來啟動然後連接到 <code class="docutils literal"><span class="pre">http://localhost:8000</span></code> 就可以成功的瀏覽到 Hello World 頁面而不是預設的 Django 回應頁面，代表可以運作。假如你沒有得到回應，請參考 <a class="reference internal" href="installation.html"><span class="doc">installed Channels correctly</span></a> 。</p>
<p>現在，這還不夠酷 - Django 本來就以已經能夠處理原生的 HTTP 回覆。讓我們嘗試一些 WebSockets 並且做一些基礎的聊天服務。</p>
<p>我們將啟動一個簡單的服務，只用來是回覆它發送回同一個客戶端的每條消息 - 沒有跨客戶通信。 他不一定非常實用，但它是一個好可開始去撰寫 Channels consumers。</p>
<p>刪除之前的消費者與他的路由 - 從現在開始我們希望是一個一般的 Django 視圖層去服務 HTTP 請求，會有狀況發生假如你沒有指定一個針對 <code class="docutils literal"><span class="pre">http.request</span></code> 給消費者 - 並且建立一個 WebSocket 顧客替代:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In consumers.py</span>

<span class="k">def</span> <span class="nf">ws_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># ASGI WebSocket packet-received and send-packet message types</span>
    <span class="c1"># both have a &quot;text&quot; key for their textual data.</span>
    <span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="o">.</span><span class="n">send</span><span class="p">({</span>
        <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">],</span>
    <span class="p">})</span>
</pre></div>
</div>
<p>掛勾它到 <code class="docutils literal"><span class="pre">websocket.receive</span></code> channel 如下</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In routing.py</span>
<span class="kn">from</span> <span class="nn">channels.routing</span> <span class="k">import</span> <span class="n">route</span>
<span class="kn">from</span> <span class="nn">myapp.consumers</span> <span class="k">import</span> <span class="n">ws_message</span>

<span class="n">channel_routing</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.receive&quot;</span><span class="p">,</span> <span class="n">ws_message</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>現在讓我們看看它們在做些什麼。它綑綁在 <code class="docutils literal"><span class="pre">websocket.receice</span></code> channel，這意味著從 WebSocket packet 由客戶端發送給我們時它將收到一個訊息。</p>
<p>當它得到這個訊息時，他會得從而到 <code class="docutils literal"><span class="pre">reply_channel</span></code> 屬性，他是從 client 端得到唯一的 channel 回應，接著使用 <code class="docutils literal"><span class="pre">send()</span></code> 方法送出一些內容返回 client。</p>
<p>Let&#8217;s test it! Run <code class="docutils literal"><span class="pre">runserver</span></code>, open a browser, navigate to a page on the server
(you can&#8217;t use any page&#8217;s console because of origin restrictions), and put the
following into the JavaScript console to open a WebSocket and send some data
down it (you might need to change the socket address if you&#8217;re using a
development VM or similar)</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="c1">// Note that the path doesn&#39;t matter for routing; any WebSocket</span>
<span class="c1">// connection gets bumped over to WebSocket consumers</span>
<span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="s2">&quot;ws://&quot;</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">host</span> <span class="o">+</span> <span class="s2">&quot;/chat/&quot;</span><span class="p">);</span>
<span class="nx">socket</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s2">&quot;hello world&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Call onopen directly if socket is already open</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">socket</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="nx">WebSocket</span><span class="p">.</span><span class="nx">OPEN</span><span class="p">)</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span><span class="p">();</span>
</pre></div>
</div>
<p>你應該看到一個提示立刻回傳並且說 &#8220;hello world&#8221; - 你的訊息已經被往返透過伺服器並且回覆去觸發這個提示。</p>
</div>
<div class="section" id="groups">
<h2>群組<a class="headerlink" href="#groups" title="本標題的永久連結">¶</a></h2>
<p>現在讓我們建立我們的 echo 伺服器進入一個實際的聊天伺服器，所以人們可以和其他人彼此交談。要完成這個我們將使用 Groups，其中一個 :doc&#8221;<cite>core concepts&lt;concepts&gt;</cite> of Channels，接著我們的基本方式是做多播消息。</p>
<p>要完成這個，我們將 hook up <code class="docutils literal"><span class="pre">websocket.connect</span></code> 與 <code class="docutils literal"><span class="pre">websocket.disconnect</span></code> channels 去新增與移除我們的 clients 從 Group 當他們連接或是中斷，像是:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In consumers.py</span>
<span class="kn">from</span> <span class="nn">channels</span> <span class="k">import</span> <span class="n">Group</span>

<span class="c1"># Connected to websocket.connect</span>
<span class="k">def</span> <span class="nf">ws_add</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Accept the incoming connection</span>
    <span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="o">.</span><span class="n">send</span><span class="p">({</span><span class="s2">&quot;accept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
    <span class="c1"># Add them to the chat group</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>

<span class="c1"># Connected to websocket.disconnect</span>
<span class="k">def</span> <span class="nf">ws_disconnect</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">備註</p>
<p class="last">You need to explicitly accept WebSocket connections if you override connect
by sending <code class="docutils literal"><span class="pre">accept:</span> <span class="pre">True</span></code> - you can also reject them at connection time,
before they open, by sending <code class="docutils literal"><span class="pre">close:</span> <span class="pre">True</span></code>.</p>
</div>
<p>當然，如果你已經讀完 <a class="reference internal" href="concepts.html"><span class="doc">Channels 的概念</span></a> ，則你知道加到 groups 中的 channels 只要他們的訊息過期，則 channel 也跟著過期。 ( 每一個 channel layer 都有訊息的過期時限，通常是 30 秒至數分鐘，通常可以設定。 ) - 但是 <code class="docutils literal"><span class="pre">disconnect</span></code> handler 在任何時間都可以被呼叫。</p>
<div class="admonition note">
<p class="first admonition-title">備註</p>
<p>Channel 的設計會期望他可以在傳訊息失敗時繼續工作。它假設少數的訊息可能不會被成功的發送出去，因此，其核心的功能在設計上會預期有失敗的發生，所以當訊息沒有被送出去的時候，不會造成系統崩潰。</p>
<p class="last">We suggest you design your applications the same way - rather than relying
on 100% guaranteed delivery, which Channels won&#8217;t give you, look at each
failure case and program something to expect and handle it - be that retry
logic, partial content handling, or just having something not work that one
time. HTTP requests are just as fallible, and most people&#8217;s response to that
is a generic error page!</p>
</div>
<p id="websocket-example">Now, that&#8217;s taken care of adding and removing WebSocket send channels for the
<code class="docutils literal"><span class="pre">chat</span></code> group; all we need to do now is take care of message sending. Instead
of echoing the message back to the client like we did above, we&#8217;ll instead send
it to the whole <code class="docutils literal"><span class="pre">Group</span></code>, which means any client who&#8217;s been added to it will
get the message. Here&#8217;s all the code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In consumers.py</span>
<span class="kn">from</span> <span class="nn">channels</span> <span class="k">import</span> <span class="n">Group</span>

<span class="c1"># Connected to websocket.connect</span>
<span class="k">def</span> <span class="nf">ws_add</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Accept the connection</span>
    <span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="o">.</span><span class="n">send</span><span class="p">({</span><span class="s2">&quot;accept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
    <span class="c1"># Add to the chat group</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>

<span class="c1"># Connected to websocket.receive</span>
<span class="k">def</span> <span class="nf">ws_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">send</span><span class="p">({</span>
        <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="s2">&quot;[user] </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">],</span>
    <span class="p">})</span>

<span class="c1"># Connected to websocket.disconnect</span>
<span class="k">def</span> <span class="nf">ws_disconnect</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>
</pre></div>
</div>
<p>And what our routing should look like in <code class="docutils literal"><span class="pre">routing.py</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">channels.routing</span> <span class="k">import</span> <span class="n">route</span>
<span class="kn">from</span> <span class="nn">myapp.consumers</span> <span class="k">import</span> <span class="n">ws_add</span><span class="p">,</span> <span class="n">ws_message</span><span class="p">,</span> <span class="n">ws_disconnect</span>

<span class="n">channel_routing</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.connect&quot;</span><span class="p">,</span> <span class="n">ws_add</span><span class="p">),</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.receive&quot;</span><span class="p">,</span> <span class="n">ws_message</span><span class="p">),</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.disconnect&quot;</span><span class="p">,</span> <span class="n">ws_disconnect</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal"><span class="pre">http.request</span></code> route is no longer present - if we leave it
out, then Django will route HTTP requests to the normal view system by default,
which is probably what you want. Even if you have a <code class="docutils literal"><span class="pre">http.request</span></code> route that
matches just a subset of paths or methods, the ones that don&#8217;t match will still
fall through to the default handler, which passes it into URL routing and the
views.</p>
<p>With all that code, you now have a working set of a logic for a chat server.
Test time! Run <code class="docutils literal"><span class="pre">runserver</span></code>, open a browser and use that same JavaScript
code in the developer console as before</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="c1">// Note that the path doesn&#39;t matter right now; any WebSocket</span>
<span class="c1">// connection gets bumped over to WebSocket consumers</span>
<span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="s2">&quot;ws://&quot;</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">host</span> <span class="o">+</span> <span class="s2">&quot;/chat/&quot;</span><span class="p">);</span>
<span class="nx">socket</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s2">&quot;hello world&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Call onopen directly if socket is already open</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">socket</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="nx">WebSocket</span><span class="p">.</span><span class="nx">OPEN</span><span class="p">)</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span><span class="p">();</span>
</pre></div>
</div>
<p>You should see an alert come back immediately saying &#8220;hello world&#8221; - but this
time, you can open another tab and do the same there, and both tabs will
receive the message and show an alert. Any incoming message is sent to the
<code class="docutils literal"><span class="pre">chat</span></code> group by the <code class="docutils literal"><span class="pre">ws_message</span></code> consumer, and both your tabs will have
been put into the <code class="docutils literal"><span class="pre">chat</span></code> group when they connected.</p>
<p>Feel free to put some calls to <code class="docutils literal"><span class="pre">print</span></code> in your handler functions too, if you
like, so you can understand when they&#8217;re called. You can also use <code class="docutils literal"><span class="pre">pdb</span></code> and
other similar methods you&#8217;d use to debug normal Django projects.</p>
</div>
<div class="section" id="running-with-channels">
<h2>Running with Channels<a class="headerlink" href="#running-with-channels" title="本標題的永久連結">¶</a></h2>
<p>Because Channels takes Django into a multi-process model, you no longer run
everything in one process along with a WSGI server (of course, you&#8217;re still
free to do that if you don&#8217;t want to use Channels). Instead, you run one or
more <em>interface servers</em>, and one or more <em>worker servers</em>, connected by
that <em>channel layer</em> you configured earlier.</p>
<p>There are multiple kinds of &#8220;interface servers&#8221;, and each one will service a
different type of request - one might do both WebSocket and HTTP requests, while
another might act as an SMS message gateway, for example.</p>
<p>These are separate from the &#8220;worker servers&#8221; where Django will run actual logic,
though, and so the <em>channel layer</em> transports the content of channels across
the network. In a production scenario, you&#8217;d usually run <em>worker servers</em>
as a separate cluster from the <em>interface servers</em>, though of course you
can run both as separate processes on one machine too.</p>
<p>By default, Django doesn&#8217;t have a channel layer configured - it doesn&#8217;t need one to run
normal WSGI requests, after all. As soon as you try to add some consumers,
though, you&#8217;ll need to configure one.</p>
<p>In the example above we used the in-memory channel layer implementation
as our default channel layer. This just stores all the channel data in a dict
in memory, and so isn&#8217;t actually cross-process; it only works inside
<code class="docutils literal"><span class="pre">runserver</span></code>, as that runs the interface and worker servers in different threads
inside the same process. When you deploy to production, you&#8217;ll need to
use a channel layer like the Redis backend <code class="docutils literal"><span class="pre">asgi_redis</span></code> that works cross-process;
see <a class="reference internal" href="backends.html"><span class="doc">通道層類型</span></a> for more.</p>
<p>The second thing, once we have a networked channel backend set up, is to make
sure we&#8217;re running an interface server that&#8217;s capable of serving WebSockets.
To solve this, Channels comes with <code class="docutils literal"><span class="pre">daphne</span></code>, an interface server
that can handle both HTTP and WebSockets at the same time, and then ties this
in to run when you run <code class="docutils literal"><span class="pre">runserver</span></code> - you shouldn&#8217;t notice any difference
from the normal Django <code class="docutils literal"><span class="pre">runserver</span></code>, though some of the options may be a little
different.</p>
<p><em>(Under the hood, runserver is now running Daphne in one thread and a worker
with autoreload in another - it&#8217;s basically a miniature version of a deployment,
but all in one process)</em></p>
<p>Let&#8217;s try out the Redis backend - Redis runs on pretty much every machine, and
has a very small overhead, which makes it perfect for this kind of thing. Install
the <code class="docutils literal"><span class="pre">asgi_redis</span></code> package using <code class="docutils literal"><span class="pre">pip</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">asgi_redis</span>
</pre></div>
</div>
<p>and set up your channel layer like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In settings.py</span>
<span class="n">CHANNEL_LAYERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;BACKEND&quot;</span><span class="p">:</span> <span class="s2">&quot;asgi_redis.RedisChannelLayer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CONFIG&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;hosts&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">6379</span><span class="p">)],</span>
        <span class="p">},</span>
        <span class="s2">&quot;ROUTING&quot;</span><span class="p">:</span> <span class="s2">&quot;myproject.routing.channel_routing&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You&#8217;ll also need to install the Redis server - there are downloads available
for Mac OS and Windows, and it&#8217;s in pretty much every linux distribution&#8217;s
package manager. For example, on Ubuntu, you can just:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">redis</span><span class="o">-</span><span class="n">server</span>
</pre></div>
</div>
<p>Fire up <code class="docutils literal"><span class="pre">runserver</span></code>, and it&#8217;ll work as before - unexciting, like good
infrastructure should be. You can also try out the cross-process nature; run
these two commands in two terminals:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">manage.py</span> <span class="pre">runserver</span> <span class="pre">--noworker</span></code></li>
<li><code class="docutils literal"><span class="pre">manage.py</span> <span class="pre">runworker</span></code></li>
</ul>
<p>As you can probably guess, this disables the worker threads in <code class="docutils literal"><span class="pre">runserver</span></code>
and handles them in a separate process. You can pass <code class="docutils literal"><span class="pre">-v</span> <span class="pre">2</span></code> to <code class="docutils literal"><span class="pre">runworker</span></code>
if you want to see logging as it runs the consumers.</p>
<p>If Django is in debug mode (<code class="docutils literal"><span class="pre">DEBUG=True</span></code>), then <code class="docutils literal"><span class="pre">runworker</span></code> will serve
static files, as <code class="docutils literal"><span class="pre">runserver</span></code> does. Just like a normal Django setup, you&#8217;ll
have to set up your static file serving for when <code class="docutils literal"><span class="pre">DEBUG</span></code> is turned off.</p>
</div>
<div class="section" id="persisting-data">
<h2>Persisting Data<a class="headerlink" href="#persisting-data" title="本標題的永久連結">¶</a></h2>
<p>Echoing messages is a nice simple example, but it&#8217;s ignoring the real
need for a system like this - persistent state for connections.
Let&#8217;s consider a basic chat site where a user requests a chat room upon initial
connection, as part of the query string (e.g. <code class="docutils literal"><span class="pre">wss://host/websocket?room=abc</span></code>).</p>
<p>The <code class="docutils literal"><span class="pre">reply_channel</span></code> attribute you&#8217;ve seen before is our unique pointer to the
open WebSocket - because it varies between different clients, it&#8217;s how we can
keep track of &#8220;who&#8221; a message is from. Remember, Channels is network-transparent
and can run on multiple workers, so you can&#8217;t just store things locally in
global variables or similar.</p>
<p>Instead, the solution is to persist information keyed by the <code class="docutils literal"><span class="pre">reply_channel</span></code> in
some other data store - sound familiar? This is what Django&#8217;s session framework
does for HTTP requests, using a cookie as the key. Wouldn&#8217;t it be useful if
we could get a session using the <code class="docutils literal"><span class="pre">reply_channel</span></code> as a key?</p>
<p>Channels provides a <code class="docutils literal"><span class="pre">channel_session</span></code> decorator for this purpose - it
provides you with an attribute called <code class="docutils literal"><span class="pre">message.channel_session</span></code> that acts
just like a normal Django session.</p>
<p>Let&#8217;s use it now to build a chat server that expects you to pass a chatroom
name in the path of your WebSocket request (we&#8217;ll ignore auth for now - that&#8217;s next):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In consumers.py</span>
<span class="kn">from</span> <span class="nn">channels</span> <span class="k">import</span> <span class="n">Group</span>
<span class="kn">from</span> <span class="nn">channels.sessions</span> <span class="k">import</span> <span class="n">channel_session</span>

<span class="c1"># Connected to websocket.connect</span>
<span class="nd">@channel_session</span>
<span class="k">def</span> <span class="nf">ws_connect</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Accept connection</span>
    <span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="o">.</span><span class="n">send</span><span class="p">({</span><span class="s2">&quot;accept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
    <span class="c1"># Work out room name from path (ignore slashes)</span>
    <span class="n">room</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="c1"># Save room in session and add us to the group</span>
    <span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;room&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">room</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">room</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>

<span class="c1"># Connected to websocket.receive</span>
<span class="nd">@channel_session</span>
<span class="k">def</span> <span class="nf">ws_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;room&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">send</span><span class="p">({</span>
        <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">message</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">],</span>
    <span class="p">})</span>

<span class="c1"># Connected to websocket.disconnect</span>
<span class="nd">@channel_session</span>
<span class="k">def</span> <span class="nf">ws_disconnect</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;room&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>
</pre></div>
</div>
<p>Update <code class="docutils literal"><span class="pre">routing.py</span></code> as well:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># in routing.py</span>
<span class="kn">from</span> <span class="nn">channels.routing</span> <span class="k">import</span> <span class="n">route</span>
<span class="kn">from</span> <span class="nn">myapp.consumers</span> <span class="k">import</span> <span class="n">ws_connect</span><span class="p">,</span> <span class="n">ws_message</span><span class="p">,</span> <span class="n">ws_disconnect</span>

<span class="n">channel_routing</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.connect&quot;</span><span class="p">,</span> <span class="n">ws_connect</span><span class="p">),</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.receive&quot;</span><span class="p">,</span> <span class="n">ws_message</span><span class="p">),</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.disconnect&quot;</span><span class="p">,</span> <span class="n">ws_disconnect</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>If you play around with it from the console (or start building a simple
JavaScript chat client that appends received messages to a div), you&#8217;ll see
that you can set a chat room with the initial request.</p>
</div>
<div class="section" id="authentication">
<h2>Authentication<a class="headerlink" href="#authentication" title="本標題的永久連結">¶</a></h2>
<p>Now, of course, a WebSocket solution is somewhat limited in scope without the
ability to live with the rest of your website - in particular, we want to make
sure we know what user we&#8217;re talking to, in case we have things like private
chat channels (we don&#8217;t want a solution where clients just ask for the right
channels, as anyone could change the code and just put in private channel names)</p>
<p>It can also save you having to manually make clients ask for what they want to
see; if I see you open a WebSocket to my &#8220;updates&#8221; endpoint, and I know which
user you are, I can just auto-add that channel to all the relevant groups (mentions
of that user, for example).</p>
<p>Handily, as WebSockets start off using the HTTP protocol, they have a lot of
familiar features, including a path, GET parameters, and cookies. We&#8217;d like to
use these to hook into the familiar Django session and authentication systems;
after all, WebSockets are no good unless we can identify who they belong to
and do things securely.</p>
<p>In addition, we don&#8217;t want the interface servers storing data or trying to run
authentication; they&#8217;re meant to be simple, lean, fast processes without much
state, and so we&#8217;ll need to do our authentication inside our consumer functions.</p>
<p>Fortunately, because Channels has an underlying spec for WebSockets and other
messages (<a class="reference internal" href="asgi.html"><span class="doc">ASGI</span></a>), it ships with decorators that help you with
both authentication and getting the underlying Django session (which is what
Django authentication relies on).</p>
<p>Channels can use Django sessions either from cookies (if you&#8217;re running your
websocket server on the same domain as your main site, using something like Daphne),
or from a <code class="docutils literal"><span class="pre">session_key</span></code> GET parameter, which works if you want to keep
running your HTTP requests through a WSGI server and offload WebSockets to a
second server process on another domain.</p>
<p>You get access to a user&#8217;s normal Django session using the <code class="docutils literal"><span class="pre">http_session</span></code>
decorator - that gives you a <code class="docutils literal"><span class="pre">message.http_session</span></code> attribute that behaves
just like <code class="docutils literal"><span class="pre">request.session</span></code>. You can go one further and use <code class="docutils literal"><span class="pre">http_session_user</span></code>
which will provide a <code class="docutils literal"><span class="pre">message.user</span></code> attribute as well as the session attribute.</p>
<p>Now, one thing to note is that you only get the detailed HTTP information
during the <code class="docutils literal"><span class="pre">connect</span></code> message of a WebSocket connection (you can read more
about that in the <a class="reference internal" href="asgi.html"><span class="doc">ASGI spec</span></a>) - this means we&#8217;re not
wasting bandwidth sending the same information over the wire needlessly.</p>
<p>This also means we&#8217;ll have to grab the user in the connection handler and then
store it in the session; thankfully, Channels ships with both a <code class="docutils literal"><span class="pre">channel_session_user</span></code>
decorator that works like the <code class="docutils literal"><span class="pre">http_session_user</span></code> decorator we mentioned above but
loads the user from the <em>channel</em> session rather than the <em>HTTP</em> session,
and a function called <code class="docutils literal"><span class="pre">transfer_user</span></code> which replicates a user from one session
to another. Even better, it combines all of these into a <code class="docutils literal"><span class="pre">channel_session_user_from_http</span></code>
decorator.</p>
<p>Bringing that all together, let&#8217;s make a chat server where users can only
chat to people with the same first letter of their username:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In consumers.py</span>
<span class="kn">from</span> <span class="nn">channels</span> <span class="k">import</span> <span class="n">Channel</span><span class="p">,</span> <span class="n">Group</span>
<span class="kn">from</span> <span class="nn">channels.sessions</span> <span class="k">import</span> <span class="n">channel_session</span>
<span class="kn">from</span> <span class="nn">channels.auth</span> <span class="k">import</span> <span class="n">channel_session_user</span><span class="p">,</span> <span class="n">channel_session_user_from_http</span>

<span class="c1"># Connected to websocket.connect</span>
<span class="nd">@channel_session_user_from_http</span>
<span class="k">def</span> <span class="nf">ws_add</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Accept connection</span>
    <span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="o">.</span><span class="n">send</span><span class="p">({</span><span class="s2">&quot;accept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
    <span class="c1"># Add them to the right group</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>

<span class="c1"># Connected to websocket.receive</span>
<span class="nd">@channel_session_user</span>
<span class="k">def</span> <span class="nf">ws_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">send</span><span class="p">({</span>
        <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">message</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">],</span>
    <span class="p">})</span>

<span class="c1"># Connected to websocket.disconnect</span>
<span class="nd">@channel_session_user</span>
<span class="k">def</span> <span class="nf">ws_disconnect</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>
</pre></div>
</div>
<p>If you&#8217;re just using <code class="docutils literal"><span class="pre">runserver</span></code> (and so Daphne), you can just connect
and your cookies should transfer your auth over. If you were running WebSockets
on a separate domain, you&#8217;d have to remember to provide the
Django session ID as part of the URL, like this</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="s2">&quot;ws://127.0.0.1:9000/?session_key=abcdefg&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>You can get the current session key in a template with <code class="docutils literal"><span class="pre">{{</span> <span class="pre">request.session.session_key</span> <span class="pre">}}</span></code>.
Note that this can&#8217;t work with signed cookie sessions - since only HTTP
responses can set cookies, it needs a backend it can write to to separately
store state.</p>
</div>
<div class="section" id="security">
<h2>Security<a class="headerlink" href="#security" title="本標題的永久連結">¶</a></h2>
<p>Unlike AJAX requests, WebSocket requests are not limited by the Same-Origin
policy. This means you don&#8217;t have to take any extra steps when you have an HTML
page served by host A containing JavaScript code wanting to connect to a
WebSocket on Host B.</p>
<p>While this can be convenient, it also implies that by default any third-party
site can connect to your WebSocket application. When you are using the
<code class="docutils literal"><span class="pre">http_session_user</span></code> or the <code class="docutils literal"><span class="pre">channel_session_user_from_http</span></code> decorator, this
connection would be authenticated.</p>
<p>The WebSocket specification requires browsers to send the origin of a WebSocket
request in the HTTP header named <code class="docutils literal"><span class="pre">Origin</span></code>, but validating that header is left
to the server.</p>
<p>You can use the decorator <code class="docutils literal"><span class="pre">channels.security.websockets.allowed_hosts_only</span></code>
on a <code class="docutils literal"><span class="pre">websocket.connect</span></code> consumer to only allow requests originating
from hosts listed in the <code class="docutils literal"><span class="pre">ALLOWED_HOSTS</span></code> setting:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In consumers.py</span>
<span class="kn">from</span> <span class="nn">channels</span> <span class="k">import</span> <span class="n">Channel</span><span class="p">,</span> <span class="n">Group</span>
<span class="kn">from</span> <span class="nn">channels.sessions</span> <span class="k">import</span> <span class="n">channel_session</span>
<span class="kn">from</span> <span class="nn">channels.auth</span> <span class="k">import</span> <span class="n">channel_session_user</span><span class="p">,</span> <span class="n">channel_session_user_from_http</span>
<span class="kn">from</span> <span class="nn">channels.security.websockets</span> <span class="k">import</span> <span class="n">allowed_hosts_only</span><span class="o">.</span>

<span class="c1"># Connected to websocket.connect</span>
<span class="nd">@allowed_hosts_only</span>
<span class="nd">@channel_session_user_from_http</span>
<span class="k">def</span> <span class="nf">ws_add</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Accept connection</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Requests from other hosts or requests with missing or invalid origin header
are now rejected.</p>
<p>The name <code class="docutils literal"><span class="pre">allowed_hosts_only</span></code> is an alias for the class-based decorator
<code class="docutils literal"><span class="pre">AllowedHostsOnlyOriginValidator</span></code>, which inherits from
<code class="docutils literal"><span class="pre">BaseOriginValidator</span></code>. If you have custom requirements for origin validation,
create a subclass and overwrite the method
<code class="docutils literal"><span class="pre">validate_origin(self,</span> <span class="pre">message,</span> <span class="pre">origin)</span></code>. It must return True when a message
should be accepted, False otherwise.</p>
</div>
<div class="section" id="routing">
<h2>Routing<a class="headerlink" href="#routing" title="本標題的永久連結">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">routing.py</span></code> file acts very much like Django&#8217;s <code class="docutils literal"><span class="pre">urls.py</span></code>, including the
ability to route things to different consumers based on <code class="docutils literal"><span class="pre">path</span></code>, or any other
message attribute that&#8217;s a string (for example, <code class="docutils literal"><span class="pre">http.request</span></code> messages have
a <code class="docutils literal"><span class="pre">method</span></code> key you could route based on).</p>
<p>Much like urls, you route using regular expressions; the main difference is that
because the <code class="docutils literal"><span class="pre">path</span></code> is not special-cased - Channels doesn&#8217;t know that it&#8217;s a URL -
you have to start patterns with the root <code class="docutils literal"><span class="pre">/</span></code>, and end includes without a <code class="docutils literal"><span class="pre">/</span></code>
so that when the patterns combine, they work correctly.</p>
<p>Finally, because you&#8217;re matching against message contents using keyword arguments,
you can only use named groups in your regular expressions! Here&#8217;s an example of
routing our chat from above:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">http_routing</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;http.request&quot;</span><span class="p">,</span> <span class="n">poll_consumer</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;^/poll/$&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;^POST$&quot;</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">chat_routing</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.connect&quot;</span><span class="p">,</span> <span class="n">chat_connect</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;^/(?P&lt;room&gt;[a-zA-Z0-9_]+)/$&quot;</span><span class="p">),</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.disconnect&quot;</span><span class="p">,</span> <span class="n">chat_disconnect</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">routing</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># You can use a string import path as the first argument as well.</span>
    <span class="n">include</span><span class="p">(</span><span class="n">chat_routing</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;^/chat&quot;</span><span class="p">),</span>
    <span class="n">include</span><span class="p">(</span><span class="n">http_routing</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>The routing is resolved in order, short-circuiting around the
includes if one or more of their matches fails. You don&#8217;t have to start with
the <code class="docutils literal"><span class="pre">^</span></code> symbol - we use Python&#8217;s <code class="docutils literal"><span class="pre">re.match</span></code> function, which starts at the
start of a line anyway - but it&#8217;s considered good practice.</p>
<p>When an include matches part of a message value, it chops off the bit of the
value it matched before passing it down to its routes or sub-includes, so you
can put the same routing under multiple includes with different prefixes if
you like.</p>
<p>Because these matches come through as keyword arguments, we could modify our
consumer above to use a room based on URL rather than username:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Connected to websocket.connect</span>
<span class="nd">@channel_session_user_from_http</span>
<span class="k">def</span> <span class="nf">ws_add</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">room</span><span class="p">):</span>
    <span class="c1"># Add them to the right group</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">room</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>
    <span class="c1"># Accept the connection request</span>
    <span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="o">.</span><span class="n">send</span><span class="p">({</span><span class="s2">&quot;accept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>In the next section, we&#8217;ll change to sending the <code class="docutils literal"><span class="pre">room</span></code> as a part of the
WebSocket message - which you might do if you had a multiplexing client -
but you could use routing there as well.</p>
</div>
<div class="section" id="models">
<h2>Models<a class="headerlink" href="#models" title="本標題的永久連結">¶</a></h2>
<p>So far, we&#8217;ve just been taking incoming messages and rebroadcasting them to
other clients connected to the same group, but this isn&#8217;t that great; really,
we want to persist messages to a datastore, and we&#8217;d probably like to be
able to inject messages into chatrooms from things other than WebSocket client
connections (perhaps a built-in bot, or server status messages).</p>
<p>Thankfully, we can just use Django&#8217;s ORM to handle persistence of messages and
easily integrate the send into the save flow of the model, rather than the
message receive - that way, any new message saved will be broadcast to all
the appropriate clients, no matter where it&#8217;s saved from.</p>
<p>We&#8217;ll even take some performance considerations into account: We&#8217;ll make our
own custom channel for new chat messages and move the model save and the chat
broadcast into that, meaning the sending process/consumer can move on
immediately and not spend time waiting for the database save and the
(slow on some backends) <code class="docutils literal"><span class="pre">Group.send()</span></code> call.</p>
<p>Let&#8217;s see what that looks like, assuming we
have a ChatMessage model with <code class="docutils literal"><span class="pre">message</span></code> and <code class="docutils literal"><span class="pre">room</span></code> fields:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In consumers.py</span>
<span class="kn">from</span> <span class="nn">channels</span> <span class="k">import</span> <span class="n">Channel</span>
<span class="kn">from</span> <span class="nn">channels.sessions</span> <span class="k">import</span> <span class="n">channel_session</span>
<span class="kn">from</span> <span class="nn">.models</span> <span class="k">import</span> <span class="n">ChatMessage</span>

<span class="c1"># Connected to chat-messages</span>
<span class="k">def</span> <span class="nf">msg_consumer</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Save to model</span>
    <span class="n">room</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="s1">&#39;room&#39;</span><span class="p">]</span>
    <span class="n">ChatMessage</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
        <span class="n">room</span><span class="o">=</span><span class="n">room</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># Broadcast to listening sockets</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">room</span><span class="p">)</span><span class="o">.</span><span class="n">send</span><span class="p">({</span>
        <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">],</span>
    <span class="p">})</span>

<span class="c1"># Connected to websocket.connect</span>
<span class="nd">@channel_session</span>
<span class="k">def</span> <span class="nf">ws_connect</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Work out room name from path (ignore slashes)</span>
    <span class="n">room</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="c1"># Save room in session and add us to the group</span>
    <span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;room&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">room</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">room</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>
    <span class="c1"># Accept the connection request</span>
    <span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="o">.</span><span class="n">send</span><span class="p">({</span><span class="s2">&quot;accept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>

<span class="c1"># Connected to websocket.receive</span>
<span class="nd">@channel_session</span>
<span class="k">def</span> <span class="nf">ws_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Stick the message onto the processing queue</span>
    <span class="n">Channel</span><span class="p">(</span><span class="s2">&quot;chat-messages&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">send</span><span class="p">({</span>
        <span class="s2">&quot;room&quot;</span><span class="p">:</span> <span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;room&#39;</span><span class="p">],</span>
        <span class="s2">&quot;message&quot;</span><span class="p">:</span> <span class="n">message</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">],</span>
    <span class="p">})</span>

<span class="c1"># Connected to websocket.disconnect</span>
<span class="nd">@channel_session</span>
<span class="k">def</span> <span class="nf">ws_disconnect</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;room&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>
</pre></div>
</div>
<p>Update <code class="docutils literal"><span class="pre">routing.py</span></code> as well:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># in routing.py</span>
<span class="kn">from</span> <span class="nn">channels.routing</span> <span class="k">import</span> <span class="n">route</span>
<span class="kn">from</span> <span class="nn">myapp.consumers</span> <span class="k">import</span> <span class="n">ws_connect</span><span class="p">,</span> <span class="n">ws_message</span><span class="p">,</span> <span class="n">ws_disconnect</span><span class="p">,</span> <span class="n">msg_consumer</span>

<span class="n">channel_routing</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.connect&quot;</span><span class="p">,</span> <span class="n">ws_connect</span><span class="p">),</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.receive&quot;</span><span class="p">,</span> <span class="n">ws_message</span><span class="p">),</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;websocket.disconnect&quot;</span><span class="p">,</span> <span class="n">ws_disconnect</span><span class="p">),</span>
    <span class="n">route</span><span class="p">(</span><span class="s2">&quot;chat-messages&quot;</span><span class="p">,</span> <span class="n">msg_consumer</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Note that we could add messages onto the <code class="docutils literal"><span class="pre">chat-messages</span></code> channel from anywhere;
inside a View, inside another model&#8217;s <code class="docutils literal"><span class="pre">post_save</span></code> signal, inside a management
command run via <code class="docutils literal"><span class="pre">cron</span></code>. If we wanted to write a bot, too, we could put its
listening logic inside the <code class="docutils literal"><span class="pre">chat-messages</span></code> consumer, as every message would
pass through it.</p>
</div>
<div class="section" id="enforcing-ordering">
<span id="id1"></span><h2>Enforcing Ordering<a class="headerlink" href="#enforcing-ordering" title="本標題的永久連結">¶</a></h2>
<p>There&#8217;s one final concept we want to introduce you to before you go on to build
sites with Channels - consumer ordering.</p>
<p>Because Channels is a distributed system that can have many workers, by default
it just processes messages in the order the workers get them off the queue.
It&#8217;s entirely feasible for a WebSocket interface server to send out two
<code class="docutils literal"><span class="pre">receive</span></code> messages close enough together that a second worker will pick
up and start processing the second message before the first worker has
finished processing the first.</p>
<p>This is particularly annoying if you&#8217;re storing things in the session in the
one consumer and trying to get them in the other consumer - because
the <code class="docutils literal"><span class="pre">connect</span></code> consumer hasn&#8217;t exited, its session hasn&#8217;t saved. You&#8217;d get the
same effect if someone tried to request a view before the login view had finished
processing, of course, but HTTP requests usually come in a bit slower from clients.</p>
<p>Channels has a solution - the <code class="docutils literal"><span class="pre">enforce_ordering</span></code> decorator. All WebSocket
messages contain an <code class="docutils literal"><span class="pre">order</span></code> key, and this decorator uses that to make sure that
messages are consumed in the right order. In addition, the <code class="docutils literal"><span class="pre">connect</span></code> message
blocks the socket opening until it&#8217;s responded to, so you are always guaranteed
that <code class="docutils literal"><span class="pre">connect</span></code> will run before any <code class="docutils literal"><span class="pre">receives</span></code> even without the decorator.</p>
<p>The decorator uses <code class="docutils literal"><span class="pre">channel_session</span></code> to keep track of what numbered messages
have been processed, and if a worker tries to run a consumer on an out-of-order
message, it raises the <code class="docutils literal"><span class="pre">ConsumeLater</span></code> exception, which puts the message
back on the channel it came from and tells the worker to work on another message.</p>
<p>There&#8217;s a high cost to using <code class="docutils literal"><span class="pre">enforce_ordering</span></code>, which is why it&#8217;s an optional
decorator. Here&#8217;s an example of it being used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># In consumers.py</span>
<span class="kn">from</span> <span class="nn">channels</span> <span class="k">import</span> <span class="n">Channel</span><span class="p">,</span> <span class="n">Group</span>
<span class="kn">from</span> <span class="nn">channels.sessions</span> <span class="k">import</span> <span class="n">channel_session</span><span class="p">,</span> <span class="n">enforce_ordering</span>
<span class="kn">from</span> <span class="nn">channels.auth</span> <span class="k">import</span> <span class="n">channel_session_user</span><span class="p">,</span> <span class="n">channel_session_user_from_http</span>

<span class="c1"># Connected to websocket.connect</span>
<span class="nd">@channel_session_user_from_http</span>
<span class="k">def</span> <span class="nf">ws_add</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># This doesn&#39;t need a decorator - it always runs separately</span>
    <span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;sent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Add them to the right group</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>
    <span class="c1"># Accept the socket</span>
    <span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="o">.</span><span class="n">send</span><span class="p">({</span><span class="s2">&quot;accept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>

<span class="c1"># Connected to websocket.receive</span>
<span class="nd">@enforce_ordering</span>
<span class="nd">@channel_session_user</span>
<span class="k">def</span> <span class="nf">ws_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="c1"># Without enforce_ordering this wouldn&#39;t work right</span>
    <span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;sent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;sent&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">send</span><span class="p">({</span>
        <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">channel_session</span><span class="p">[</span><span class="s1">&#39;sent&#39;</span><span class="p">],</span> <span class="n">message</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]),</span>
    <span class="p">})</span>

<span class="c1"># Connected to websocket.disconnect</span>
<span class="nd">@channel_session_user</span>
<span class="k">def</span> <span class="nf">ws_disconnect</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">Group</span><span class="p">(</span><span class="s2">&quot;chat&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">reply_channel</span><span class="p">)</span>
</pre></div>
</div>
<p>Generally, the performance (and safety) of your ordering is tied to your
session backend&#8217;s performance. Make sure you choose a session backend wisely
if you&#8217;re going to rely heavily on <code class="docutils literal"><span class="pre">enforce_ordering</span></code>.</p>
</div>
<div class="section" id="next-steps">
<h2>Next Steps<a class="headerlink" href="#next-steps" title="本標題的永久連結">¶</a></h2>
<p>That covers the basics of using Channels; you&#8217;ve seen not only how to use basic
channels, but also seen how they integrate with WebSockets, how to use groups
to manage logical sets of channels, and how Django&#8217;s session and authentication
systems easily integrate with WebSockets.</p>
<p>We recommend you read through the rest of the reference documentation to see
more about what you can do with channels; in particular, you may want to look at
our <a class="reference internal" href="deploying.html"><span class="doc">部署</span></a> documentation to get an idea of how to
design and run apps in production environments.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">目錄</a></h3>
  <ul>
<li><a class="reference internal" href="#">Getting Started with Channels</a><ul>
<li><a class="reference internal" href="#first-consumers">First Consumers</a></li>
<li><a class="reference internal" href="#groups">群組</a></li>
<li><a class="reference internal" href="#running-with-channels">Running with Channels</a></li>
<li><a class="reference internal" href="#persisting-data">Persisting Data</a></li>
<li><a class="reference internal" href="#authentication">Authentication</a></li>
<li><a class="reference internal" href="#security">Security</a></li>
<li><a class="reference internal" href="#routing">Routing</a></li>
<li><a class="reference internal" href="#models">Models</a></li>
<li><a class="reference internal" href="#enforcing-ordering">Enforcing Ordering</a></li>
<li><a class="reference internal" href="#next-steps">Next Steps</a></li>
</ul>
</li>
</ul>

  <h4>上一個主題</h4>
  <p class="topless"><a href="installation.html"
                        title="上一章">安裝</a></p>
  <h4>下一個主題</h4>
  <p class="topless"><a href="deploying.html"
                        title="下一章">部署</a></p>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/getting-started.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜尋</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="前往" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="deploying.html" title="部署"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="installation.html" title="安裝"
             >上一頁</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Channels-docs-zhTW 1.1.5 說明文件</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版權所有 2018, Jason(@chairco)。
      使用 <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2 創建。
    </div>
  </body>
</html>