# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Jason(@chairco)
# This file is distributed under the same license as the Channels-doc-tw package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Channels-doc-tw 1.1.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-25 21:56+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../testing.rst:2
msgid "Testing Consumers"
msgstr ""

#: ../../testing.rst:4
msgid "When you want to write unit tests for your new Channels consumers, you'll realize that you can't use the standard Django test client to submit fake HTTP requests - instead, you'll need to submit fake Messages to your consumers, and inspect what Messages they send themselves."
msgstr ""

#: ../../testing.rst:9
msgid "We provide a ``TestCase`` subclass that sets all of this up for you, however, so you can easily write tests and check what your consumers are sending."
msgstr ""

#: ../../testing.rst:14
msgid "ChannelTestCase"
msgstr ""

#: ../../testing.rst:16
msgid "If your tests inherit from the ``channels.test.ChannelTestCase`` base class, whenever you run tests your channel layer will be swapped out for a captive in-memory layer, meaning you don't need an external server running to run tests."
msgstr ""

#: ../../testing.rst:20
msgid "Moreover, you can inject messages onto this layer and inspect ones sent to it to help test your consumers."
msgstr ""

#: ../../testing.rst:23
msgid "To inject a message onto the layer, simply call ``Channel.send()`` inside any test method on a ``ChannelTestCase`` subclass, like so::"
msgstr ""

#: ../../testing.rst:34
msgid "To receive a message from the layer, you can use ``self.get_next_message(channel)``, which handles receiving the message and converting it into a Message object for you (if you want, you can call ``receive_many`` on the underlying channel layer, but you'll get back a raw dict and channel name, which is not what consumers want)."
msgstr ""

#: ../../testing.rst:39
msgid "You can use this both to get Messages to send to consumers as their primary argument, as well as to get Messages from channels that consumers are supposed to send on to verify that they did."
msgstr ""

#: ../../testing.rst:43
msgid "You can even pass ``require=True`` to ``get_next_message`` to make the test fail if there is no message on the channel (by default, it will return you ``None`` instead)."
msgstr ""

#: ../../testing.rst:47
msgid "Here's an extended example testing a consumer that's supposed to take a value and post the square of it to the ``\"result\"`` channel::"
msgstr ""

#: ../../testing.rst:66
msgid "Generic Consumers"
msgstr ""

#: ../../testing.rst:68
msgid "You can use ``ChannelTestCase`` to test generic consumers as well. Just pass the message object from ``get_next_message`` to the constructor of the class. To test replies to a specific channel, use the ``reply_channel`` property on the ``Message`` object. For example::"
msgstr ""

#: ../../testing.rst:91
msgid "Groups"
msgstr ""

#: ../../testing.rst:93
msgid "You can test Groups in the same way as Channels inside a ``ChannelTestCase``; the entire channel layer is flushed each time a test is run, so it's safe to do group adds and sends during a test. For example::"
msgstr ""

#: ../../testing.rst:112
msgid "Clients"
msgstr ""

#: ../../testing.rst:114
msgid "For more complicated test suites you can use the ``Client`` abstraction that provides an easy way to test the full life cycle of messages with a couple of methods: ``send`` to sending message with given content to the given channel, ``consume`` to run appointed consumer for the next message, ``receive`` to getting replies for client. Very often you may need to ``send`` and than call a consumer one by one, for this purpose use ``send_and_consume`` method::"
msgstr ""

#: ../../testing.rst:131
msgid "You can use ``WSClient`` for websocket related consumers. It automatically serializes JSON content, manage cookies and headers, give easy access to the session and add ability to authorize your requests. For example::"
msgstr ""

#: ../../testing.rst:184
msgid "Instead of ``WSClient.login`` method with credentials at arguments you may call ``WSClient.force_login`` (like at django client) with the user object."
msgstr ""

#: ../../testing.rst:187
msgid "``receive`` method by default trying to deserialize json text content of a message, so if you need to pass decoding use ``receive(json=False)``, like in the example."
msgstr ""

#: ../../testing.rst:190
msgid "For testing consumers with ``enforce_ordering`` initialize ``HttpClient`` with ``ordered`` flag, but if you wanna use your own order don't use it, use content::"
msgstr ""

#: ../../testing.rst:212
msgid "Applying routes"
msgstr ""

#: ../../testing.rst:214
msgid "When you need to test your consumers without routes in settings or you want to test your consumers in a more isolate and atomic way, it will be simpler with ``apply_routes`` contextmanager and decorator for your ``ChannelTestCase``. It takes a list of routes that you want to use and overwrites existing routes::"
msgstr ""

#: ../../testing.rst:232
msgid "Test Data binding with ``WSClient``"
msgstr ""

#: ../../testing.rst:234
msgid "As you know data binding in channels works in outbound and inbound ways, so that ways tests in different ways and ``WSClient`` and ``apply_routes`` will help to do this. When you testing outbound consumers you need just import your ``Binding`` subclass with specified ``group_names``. At test you can  join to one of them, make some changes with target model and check received message. Lets test ``IntegerValueBinding`` from :doc:`data binding <binding>` with creating::"
msgstr ""

#: ../../testing.rst:276
msgid "There is another situation with inbound binding. It is used with :ref:`multiplexing`, So we apply two routes: websocket route for demultiplexer and route with internal consumer for binding itself, connect to websocket entrypoint and test different actions. For example::"
msgstr ""

#: ../../testing.rst:307
msgid "Multiple Channel Layers"
msgstr ""

#: ../../testing.rst:309
msgid "If you want to test code that uses multiple channel layers, specify the alias of the layers you want to mock as the ``test_channel_aliases`` attribute on the ``ChannelTestCase`` subclass; by default, only the ``default`` layer is mocked."
msgstr ""

#: ../../testing.rst:314
msgid "You can pass an ``alias`` argument to ``get_next_message``, ``Client`` and ``Channel`` to use a different layer too."
msgstr ""

#: ../../testing.rst:318
msgid "Live Server Test Case"
msgstr ""

#: ../../testing.rst:320
msgid "You can use browser automation libraries like Selenium or Splinter to check your application against real layer installation.  First of all provide ``TEST_CONFIG`` setting to prevent overlapping with running dev environment."
msgstr ""

#: ../../testing.rst:340
msgid "Now use ``ChannelLiveServerTestCase`` for your acceptance tests."
msgstr ""

#: ../../testing.rst:356
msgid "In the test above Daphne and Channels worker processes were fired up. These processes run your project against the test database and the default channel layer you spacify in the settings.  If channel layer support ``flush`` extension, initial cleanup will be done.  So do not run this code against your production environment.  When channels infrastructure is ready default web browser will be also started.  You can open your website in the real browser which can execute JavaScript and operate on WebSockets.  ``live_server_ws_url`` property is also provided if you decide to run messaging directly from Python."
msgstr ""

#: ../../testing.rst:366
msgid "By default live server test case will serve static files.  To disable this feature override `serve_static` class attribute."
msgstr ""

